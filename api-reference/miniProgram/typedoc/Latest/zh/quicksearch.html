<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes ClientYunXinMiniappSDK Classes Classes Client YunXinMiniappSDK × Search results Close Documentation generated by JSDoc 3.6.11 on 2025-08-18T17:38:56+08:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes ClientYunXinMiniappSDK NERTC Miniapp SDK for WeChat API Reference NERTC mini SDK提供基于网络的视频通话和语音通话功能，支持在微信小程序中调用API快速建立音视频连接，进行音视频通话和推流的服务。 基本API文档 YunXinMiniappSDK 是基础对象，是所有可调用方法的入口 Client 是客户端对象，负责通话中的本地或远程用户的核心操作。 Client对象的基础方法 NERTC Miniapp SDK for Wechat 的 Client 方法提供 NERTC 的核心功能，包含如下 API： 方法 功能描述 起始版本 Client.init 初始化对象 4.0.0 Client.setRole 设置用户角色 4.2.0 Client.join 加入音视频频道 4.0.0 Client.leave 离开音视频频道 4.0.0 Client.publish 发布音视频流 4.0.0 Client.unpublish 取消发布音视频流 4.0.0 Client.subscribe 接收远端音视频流 4.0.0 Client.unsubscribe 取消接收远端音视频流 4.0.0 Client.mute 停止发送本地音视频流 4.1.0 Client.unmute 停止发送本地音视频流 4.1.0 Client.setVoiceBeautifierPreset 设置本地上行美声效果 4.6.0 Client.setAudioEffectPreset 设置本地上行变声效果 4.6.0 Client.setLocalVoicePitch 调整本地上行语音音调 4.6.0 Client.setLocalVoiceEqualization 调整本地上行语音音效均衡 4.6.0 Client.addTasks 添加推流任务 4.6.0 Client.updateTasks 更新推流任务 4.6.0 Client.deleteTasks 删除推流任务 4.6.0 Client.startAsrCaptions 开启字幕&amp;翻译 4.7.1 Client.stopAsrCaptions 关闭字幕&amp;翻译 4.7.1 Client.aiManualInterrupt 打断字幕&amp;翻译 4.7.1 Client.on 监听事件 4.0.0 Client.off 取消监听事件 4.0.0 × Search results Close Documentation generated by JSDoc 3.6.11 on 2025-08-18T17:38:56+08:00 using the DocStrap template. "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Documentation Classes ClientYunXinMiniappSDK Class: Client Client new Client() Client对象，通过YunXinMiniappSDK.Client创建 Methods addTasks(options) 添加推流任务 Parameters: Name Type Description options Object Properties Name Type Description rtmpTasks Array 推流任务队列，数组类型 Returns: Type Promise Example //动直播的推流任务，可以设置多个推流任务 let rtmpTasks = [] // taskID 可选字母、数字，下划线，不超过64位 let taskId = 'taskId_1' // 设置推互动直播推流地址，一个推流任务对应一个推流房间 let streamUrl = 'rtmp://xxxxxx-1' // 设置是否进行互动直播录制，请注意与音视频通话录制区分。 let record = true let task1 = { taskId， streamUrl, record, // 整体布局参数 layout: { canvas: { //整体布局宽度 width: 1280, //整体布局高度 height: 720, //整体布局背景色（转为10进制的数，如：#FFFFFF 16进制转为10进制为 16777215） color: 16777215 }, users: [{ uid: 100, //用户id x: 0, // user1 的视频布局x偏移，相对整体布局的左上角（前提是推流发布user1的视频） y: 0, // user1 的视频布局y偏移，相对整体布局的左上角（前提是推流发布user1的视频） width: 640, // user1 的视频布局宽度（前提是推流发布user1的视频） height: 360, //user1 的视频布局高度（前提是推流发布user1的视频） adaption: 1, //自适应，值默认为1，取值：0或者1 zOrder: 1, //图层优先级 pushAudio: true, // 推流是否发布user1 的音频 pushVideo: true // 推流是否发布user1的视频 }, { uid: 200, //用户id x: 0, // user2 的视频布局x偏移，相对整体布局的左上角（前提是推流发布user2的视频） y: 0, // user2 的视频布局y偏移，相对整体布局的左上角（前提是推流发布user2的视频） width: 640, // user2 的视频布局宽度（前提是推流发布user2的视频） height: 360, //user2 的视频布局高度（前提是推流发布user2的视频） adaption: 1, //自适应，值默认为1 zOrder: 2, //图层优先级 pushAudio: true, // 推流是否发布user2 的音频 pushVideo: true // 推流是否发布user2 的视频 }], images: [{ url: \"xxxxxx\", //设置背景图片 x: 0, // 背景图片x偏移，相对整体布局的左上角 y: 0, // 背景图片y偏移，相对整体布局的左上角 width: 480, // 背景图片宽度 height: 360, //背景图片高度 adaption: 1 //自适应，值默认为1 }] }, //音视频属性的一些设置，可以不配置该内容（即task1不包括config字段） config： { audioParam: { 可以不配置该内容（即config不包括audioParam字段） bitRate: 64, //自定义音频比特率。取值范围为 10～192。语音场景建议64以上，音乐场景建议128。 channels: 2, //音频推流声道数。可以设置为1（mono）或者2（stereo）。默认为2。 codecProfile: 0, //音频编码规格。可以设置为以下值。0: 表示基本音频编码规格(默认), 1: 表示高效音频编码规格 sampleRate：48000, //音频推流采样率。可以设置为以下值: 32000, 44100, 48000（默认） singleVideoNoTrans: false //单视频直推不转码。开启后推流服务器会透传用户的视频编码，不再对视频做转码。 }, } //扩展的推流任务属性, 可以不配置该内容（即task1不包括extraInfo字段） extraInfo: '' } rtmpTasks.push(task1) // 添加推流任务 client.addTasks({rtmpTasks}).then(()=&gt;{ console.log('添加推流任务接口成功') }).catch(error=&gt;{ console.warn('添加推流任务接口失败: ', error) }) aiManualInterrupt(uid) 一般是加入开启字幕&amp;翻译之后，如果不需要接收某一个人的字幕信息，可以调用该API打断 Parameters: Name Type Description uid number 要打断字幕&amp;翻译的目标uid Returns: Type Promise Example // RTC流程 import YunXinMiniappSDK from 'path/to/NERTC_Miniapp_SDK_v4.7.4.js' client = YunXinMiniappSDK.Client({ debug: true, appkey: '' }) // 开启字幕 client.startAsrCaptions() //打断某一个人的字幕 const uid = 1000 client.aiManualInterrupt(uid).then(=&gt;{ console.log('打断字幕成功: ') }).catch(e=&gt;{ console.error('打断字幕失败: ', e) }) dataReporter(pushOrPull, type, data, uid) live-puser和live-liver数据上报接口 Parameters: Name Type Description pushOrPull String 表示是推流还是拉流 type String 表示上报的数据类型 bindstatechange: live-pusher或者live-player组件的状态变化事件。 bindnetstatus: live-pusher或者live-player组件的网络状态通知。 binderror: ive-pusher组件的渲染错误事件。 data String 表示要上报的数据 uid number 如果pushOrPull为pull，uid表示拉制定成员媒体流的uid Returns: Type Promise Example // RTC流程 import YunXinMiniappSDK from 'path/to/NERTC_Miniapp_SDK_v4.7.4.js' client = YunXinMiniappSDK.Client({ debug: true, appkey: '' }) client.dataReporter('pull', 'bindstatechange', { code: 3005, reason: '' }, uid: 1000) deleteTasks(options) 删除推流任务 Parameters: Name Type Description options Object Properties Name Type Description rtmpTasks Array 推流任务队列，数组类型 Returns: Type Promise Example // 传入需要删除的推流任务的taskId let taskIds = [] taskIds.push('taskId_1') client.deleteTasks({ taskIds }).then(()=&gt;{ console.log('删除推流任务接口调用成功') }).catch(error=&gt;{ console.warn('删除推流任务接口调用失败: ', error) }) init() 初始化对象 Parameters: Type Description null Returns: Type Promise join(joinChannelParam) 加入房间 Parameters: Name Type Description joinChannelParam Object Properties Name Type Argument Description channelName String 房间名称 token String 在 app 服务器端生成的用于鉴权的 Token uid Number | String | BigNumber | null &lt;optional&gt; 用户唯一标识ID。可设置为： + Number类型：房间内保证唯一，建议五位数以上，范围不能超过number类型限制 + String类型: uid超过了number范围，可以以string的方式传入sdk，sdk会当做BigNumber类型（bignumber.js）处理。 + BigNumber格式: uid超过了number范围，也可以直接传入BigNumber类型（bignumber.js） + null: 如果不传入，则SDK自动生成（唯一性不保证） rtmpRecord Number &lt;optional&gt; 是否开启互动直播录制，0不需要，1需要（默认0） recordAudio Number &lt;optional&gt; 是否开启音频实时音录制，0不需要，1需要（默认0） recordVideo Number &lt;optional&gt; 是否开启视频实时音录制，0不需要，1需要（默认0） recordType String &lt;optional&gt; 录制模式，0混单（产生混合录制文件+单独录制文件） 1只混（只产生混合录制文件） 2只单（只产生单独录制文件） liveEnable Number &lt;optional&gt; 是否旁路直播,0:不需要,1:需要 Returns: Type Promise leave() 离开房间 Parameters: Type Description Void Returns: Type Promise mute(mediaType) 一般是加入房间之后，操作本地是否mute 相关回调： 如果您在加入房间后调用该方法执行mute，调用成功后，房间里面的其他人会触发以下回调： mediaType设置为'audio'、undefined，远端触发mute-audio回调 mediaType设置为'video'、undefined，远端触发mute-video回调 Parameters: Name Type Description mediaType string 要禁止的媒体类型： video: 表示禁止视频。 audio: 表示禁止音频。 Returns: Type Promise Example // RTC流程 import YunXinMiniappSDK from 'path/to/NERTC_Miniapp_SDK_v4.7.4.js' client = YunXinMiniappSDK.Client({ debug: true, appkey: '' }) client.mute('audio').then(url=&gt;{ console.log('mute 音频成功: ', url) this.setData({ enableMic: true //设置live-pusher组件的enableMic属性为true }) }).catch(e=&gt;{ console.error('mute 音频失败: ', e) }) off(event) 生成client对象后，就可以通过off方法取消监听相关事件 Parameters: Name Type Description event string Client反馈的event类型： error：通知应用程序发生错误。 该回调中会包含详细的错误码和错误信息 role-Changed: 通知应用程序房间里成员的角色 stream-added: 通知应用程序已添加远端音视频流。 该回调中会包含已添加的远端用户 ID stream-removed: 通知应用程序已删除远端音视频流。 该回调中会包含已删除的远端用户 ID syncDone：通知应用程序发生错误。 该回调中会包含详细的错误码和错误信息 mute-audio：通知应用程序远端用户已停止发送音频流。 该回调中会包含停止发送音频流的用户 ID mute-video：通知应用程序远端用户已停止发送视频流。 该回调中会包含停止发送视频流的用户 ID unmute-audio：通知应用程序远端用户已恢复发送音频流。 该回调中会包含恢复发送音频流的用户 ID unmute-video：通知应用程序远端用户已恢复发送视频流。 该回调中会包含恢复发送视频流的用户 ID clientLeave：通知应用程序有人离开房间 clientJoin：通知应用程序有人加入房间 kicked：通知应用程序自己被踢出 liveRoomClose：通知应用程序房间被解散 open：通知应用程序socket建立成功 disconnect：通知应用程序音视频socket关闭 willreconnect：通知应用程序信令准备重连 reconnected：通知应用程序信令准备重连 sendCommandOverTime：通知应用程序发送命令超时 Returns: Type void Example client.off('stream-added') on(event, func) 生成client对象后，就可以通过on方法监听相关事件 Parameters: Name Type Description event string Client反馈的event类型： error：通知应用程序发生错误。 该回调中会包含详细的错误码和错误信息 role-Changed: 通知应用程序房间里成员的角色 stream-added: 通知应用程序已添加远端音视频流。 该回调中会包含已添加的远端用户 ID stream-removed: 通知应用程序已删除远端音视频流。 该回调中会包含已删除的远端用户 ID syncDone：通知应用程序发生错误。 该回调中会包含详细的错误码和错误信息 mute-audio：通知应用程序远端用户已停止发送音频流。 该回调中会包含停止发送音频流的用户 ID mute-video：通知应用程序远端用户已停止发送视频流。 该回调中会包含停止发送视频流的用户 ID unmute-audio：通知应用程序远端用户已恢复发送音频流。 该回调中会包含恢复发送音频流的用户 ID unmute-video：通知应用程序远端用户已恢复发送视频流。 该回调中会包含恢复发送视频流的用户 ID clientLeave：通知应用程序有人离开房间 clientJoin：通知应用程序有人加入房间 kicked：通知应用程序自己被踢出 liveRoomClose：通知应用程序房间被解散 open：通知应用程序socket建立成功 disconnect：通知应用程序音视频socket关闭 willreconnect：通知应用程序信令准备重连 reconnected：通知应用程序信令准备重连 sendCommandOverTime：通知应用程序发送命令超时 rtmp-tasks-status：通知应用程序, 互动直播的推流状态 asr-captions：当前房间中字幕&amp;翻译消息的通知 func function 表示监听到event之后，要执行的函数 Returns: Type void Example // RTC流程 import YunXinMiniappSDK from 'path/to/NERTC_Miniapp_SDK_v4.7.4.js' let client = YunXinMiniappSDK.Client({ debug: true, appkey: '' }) //通知应用程序发生错误。 该回调中会包含详细的错误码和错误信息 client.on('error', (data) =&gt; { console.log('音视频通知：错误') }) //通知应用程序房间里成员的角色 netcallInstance.on('role-Changed', ({uid, role, isBigNumber}) =&gt; { //如果对端uid超出了number范围，isBigNumber值为true，uid为String类型，否则isBigNumber为false，uid为number类型 console.log(`${uid} 的角色为 ${role}`) //`broadcaster`：(默认) 将用户角色设置为主播。主播可以调用 publish 和 unpublish 方法。 //`audience`: 将用户角色设置为观众。观众不能调用 publish 和 unpublish 方法。 }) //通知应用程序已添加远端音视频流。 该回调中会包含已添加的远端用户 ID client.on('stream-added', ({uid, mediaType, isBigNumber}) =&gt; { //如果对端uid超出了number范围，isBigNumber值为true，uid为String类型，否则isBigNumber为false，uid为number类型 //mediaType的值为：audio、slaveAudio、video、screenShare console.log(`${uid} 发布了自己的 ${mediaType}`) }) //通知应用程序已删除远端音视频流。 该回调中会包含已删除的远端用户 ID。 client.on('stream-removed', ({uid, mediaType, isBigNumber}) =&gt; { //如果对端uid超出了number范围，isBigNumber值为true，uid为String类型，否则isBigNumber为false，uid为number类型 console.log(`${uid}停止发布自己的 ${mediaType}`) }) //通知应用程序更新后的推流地址。 client.on('syncDone', (data) =&gt; { data.userList.map(item =&gt; { //如果对端uid超出了number范围，isBigNumber值为true，uid为String类型，否则isBigNumber为false，uid为number类型 const {uid, url, isBigNumber} = item if (uid == localUid) { console.log('更新了推流地址') } else { console.log('更新了拉流地址') } }) console.log('音视频通知：已经删除远端音视频流') }) //通知应用程序远端用户已停止发送音频流。 该回调中会包含停止发送音频流的用户 ID netcallInstance.on('mute-audio', (data) =&gt; { const {uid} = data console.log('音视频通知：对端音频mute') }) //通知应用程序远端用户已停止发送视频流。 该回调中会包含停止发送视频流的用户 ID。 netcallInstance.on('mute-video', (data) =&gt; { const {uid} = data console.log('音视频通知：对端视频mute') }) //通知应用程序远端用户已恢复发送音频流。 该回调中会包含恢复发送音频流的用户 ID。 netcallInstance.on('unmute-audio', (data) =&gt; { const {uid} = data console.log('音视频通知：对端音频恢复mute') }) //通知应用程序远端用户已恢复发送视频流。 该回调中会包含恢复发送视频流的用户 ID。 netcallInstance.on('unmute-video', (data) =&gt; { const {uid} = data console.log('音视频通知：对端视频恢复mute') }) //通知应用程序有人离开房间。 client.on('clientLeave', (data) =&gt; { //如果对端uid超出了number范围，isBigNumber值为true，uid为String类型，否则isBigNumber为false，uid为number类型 const {uid, isBigNumber} = data console.log(`${uid} 离开了房间`) console.log('音视频通知：有人离开了，清除拉流的live-player组件') }) //通知应用程序有人加入房间。 client.on('clientJoin', (data) =&gt; { //如果对端uid超出了number范围，isBigNumber值为true，uid为String类型，否则isBigNumber为false，uid为number类型 const {uid, isBigNumber} = data console.log('音视频通知：有人加入') }) //通知应用程序自己被踢出。 client.on('kicked', (data) =&gt; { console.log('音视频通知：被踢') }) //通知应用程序socket建立成功。 client.on('open', (data) =&gt; { console.log('音视频通知：socket建立成功') }) //通知应用程序音视频socket关闭。 client.on('disconnect', (data) =&gt; { console.log('音视频通知：音视频socket关闭了') //可以清除live-puser和live-player组件 }) //通知应用程序信令准备重连。 client.on('willreconnect', (data) =&gt; { console.log('音视频通知：信令准备重连') //此时可以考虑清除live-puser和live-player组件 }) //通知应用程序信令准备重连。 client.on('reconnected', (data) =&gt; { console.log('音视频通知：信令重连成功') //此时可以重新调用publish发布自己的媒体 }) //通知应用程序发送命令超时。 client.on('sendCommandOverTime', (data) =&gt; { console.log('音视频通知：发送命令超时') }) //通知应用程序房间被解散。 client.on('liveRoomClose', (data) =&gt; { console.log('音视频通知：互动直播房间解散了') }) //通知应用程序, 互动直播的推流状态 client.on('rtmp-tasks-status', ({taskId, code, msg, streamUrl}) =&gt; { console.log('音视频通知：设置的推流任务的状态发生了变更') //taskId: 设置的推流任务的id //streamUrl: 设置的推流任务对应的推流地址 if (code == 505) { console.warn('该推流任务正在推流中，状态正常') } else if (code == 506) { console.warn('该推流任务推流失败了') } else if (code == 511) { console.warn('该推流任务推流结束了') } }) client.on('asr-captions', ({ timestamp, srcUid, text, isFinal, hasTrans, transText }) =&gt; { // timestamp: 该字幕消息的触发时间戳 // srcUid: 字幕的来源uid（即谁讲的话，产生的字幕） // text: 字幕的具体内容 // isFinal: 字幕消息是否结束（由于是实时字幕，房间中人边讲话，边产生字幕，isFinal用来标识一句话是否讲完） // hasTrans: 当前是否有翻译（startAsrCaptions(sourceLang = 'AUTO', targetLang = '')，如果调用开启实时字幕的时候，设置了targetLang） // transText: 翻译的具体内容 }) publish(mediaType) 加入房间后，可以发布自己的媒体 相关回调： 如果执行publish方法，调用成功后，房间里面的其他人会触发以下回调： 远端触发stream-added回调 Parameters: Name Type Description mediaType string 要发布的媒体类型： undefined：表示空字符串，即表示同时发布音视频。 video: 表示发布视频。 audio: 表示发布音频。 Returns: Type Promise Example client.publish().then(url=&gt;{ console.log('发布成功，获取到推流地址: ', url) //将此url设置为live-pusher组件的url }).catch(e=&gt;{ console.error('关闭mic失败: ', e) }) setAudioEffectPreset(type) 设置用户上行的音频变声，默认关闭。 注意： 可以在加入房间之前或者之后设置，支持动态变更。 当房间内的本地用户和远端用户均使用小程序平台时，美声和变声的能力不会生效。当本地用户使用小程序平台，而对端使用的是移动平台、PC 平台或 Web 平台时，美声和变声能力才生效。 Parameters: Name Type Description type number 用户角色。可设置为： AUDIO_EFFECT_OFF：（默认）关闭变声音效 VOICE_CHANGER_EFFECT_ROBOT: 机器人 VOICE_CHANGER_EFFECT_GIANT: 巨人 VOICE_CHANGER_EFFECT_HORROR: 恐怖 VOICE_CHANGER_EFFECT_MATURE： 成熟 VOICE_CHANGER_EFFECT_MANTOWOMAN: 男变女 VOICE_CHANGER_EFFECT_WOMANTOMAN： 女变男 VOICE_CHANGER_EFFECT_MANTOLOLI: 男变萝莉 VOICE_CHANGER_EFFECT_WOMANTOLOLI： 女变萝莉 Returns: Type void Example const type = YunXinMiniappSDK.VOICE_CHANGER_EFFECT_ROBOT //声音变成机器人效果 client.setAudioEffectPreset(type) setLocalVoiceEqualization(bandFrequency, bandGain) 设置本地语音音效均衡，即自定义设置本地人声均衡波段的中心频率。 注意： 可以在加入房间之前或者之后设置，支持动态变更。 当房间内的本地用户和远端用户均使用小程序平台时，美声和变声的能力不会生效。当本地用户使用小程序平台，而对端使用的是移动平台、PC 平台或 Web 平台时，美声和变声能力才生效。 Parameters: Name Type Description bandFrequency number 频谱子带索引，取值范围是 [0-9]，分别代表 10 个频带，对应的中心频率是 [31，62，125，250，500，1k，2k，4k，8k，16k] Hz。 bandGain number 每个 band 的增益，单位是 dB，每一个值的范围是 [-15，15]，默认值为 0，要求整型。 Returns: Type void Example //本地语音音效均衡 let gain = 10 // 取值范围是[-15，15]。默认值为0 let bandFrequency = YunXinMiniappSDK.AUDIO_EQUALIZATION_BAND_1K; //表示中心频率为1000的位置增益设置为10 client.setLocalVoiceEqualization(bandFrequency, gain) gain = -10 // 取值范围是[-15，15]。默认值为0 bandFrequency = YunXinMiniappSDK.AUDIO_EQUALIZATION_BAND_500; //表示中心频率为1000的位置增益设置为10 client.setLocalVoiceEqualization(bandFrequency, gain) //如果想更改所有频谱子带的增益值，需要连续调用该接口 setLocalVoicePitch(pitch) 设置本地语音音调，例如将音调调高或者调低 注意： 可以在加入房间之前或者之后设置，支持动态变更。 setAudioEffectPreset 方法和 setLocalVoicePitch 方法不能共存，调用了其中任一方法后，另一方法会被重置为默认值。 当房间内的本地用户和远端用户均使用小程序平台时，美声和变声的能力不会生效。当本地用户使用小程序平台，而对端使用的是移动平台、PC 平台或 Web 平台时，美声和变声能力才生效。 Parameters: Name Type Description pitch number 语音音调大小，输入pitch区间在[0.5，2]，默认值为1.25。 Returns: Type void Example const pitch = 0.6; //pitch 输入pitch区间在[0.5，2] ，默认值为1.25 client.setLocalVoicePitch(pitch) setRole(role) 设置用户角色。默认情况下用户以主播角色加入房间。 在加入房间前，用户可以调用本接口设置本端模式为观众或主播模式。在加入房间后，用户可以通过本接口切换用户模式。 用户角色支持设置为主播（broadcaster）或观众(audience)，主播和观众的权限不同： 主播：可以操作摄像头等音视频设备、发布流、上下线对房间内其他用户可见。 观众：观众只能接收音视频流，不支持操作音视频设备、上下线不通知其他用户。 注意： 可以在加入房间之前或者之后设置。 相关回调： 如果执行publish方法，调用成功后，房间里面的其他人会触发以下回调： 远端触发role-Changed回调 主播切换为观众，远端触发clientLeave回调 观众切换为主播，远端触发clientJoin回调 Parameters: Name Type Description role string 用户角色。可设置为： broadcaster：(默认) 将用户角色设置为主播。主播可以调用 publish 和 unpublish 方法。 audience: 将用户角色设置为观众。观众不能调用 publish 和 unpublish 方法。 Returns: Type Promise Example client.setRole('broadcaster') client.on('role-Changed', ({uid, role}) =&gt; { console.log(`${uid}改变了自己角色 ${role}`) }) setVoiceBeautifierPreset(type) 设置用户上行的音频美声，默认关闭 注意： 可以在加入房间之前或者之后设置，支持动态变更。 setVoiceBeautifierPreset 方法和 setAudioEffectPreset 方法不能共存，调用了其中任一方法后，另一方法会被重置为默认值。 当房间内的本地用户和远端用户均使用小程序平台时，美声和变声的能力不会生效。当本地用户使用小程序平台，而对端使用的是移动平台、PC 平台或 Web 平台时，美声和变声能力才生效。 Parameters: Name Type Description type number 用户角色。可设置为： VOICE_BEAUTIFIER_OFF：（默认）关闭美声效果 VOICE_BEAUTIFIER_MUFFLED: 低沉效果 VOICE_BEAUTIFIER_MELLOW：圆润效果 VOICE_BEAUTIFIER_CLEAR: 清澈效果 VOICE_BEAUTIFIER_MAGNETIC： 磁性效果 VOICE_BEAUTIFIER_RECORDINGSTUDIO: 录音棚效果 VOICE_BEAUTIFIER_NATURE： 天籁效果 VOICE_BEAUTIFIER_KTV: KTV效果效果 VOICE_BEAUTIFIER_REMOTE： 悠远效果 VOICE_BEAUTIFIER_CHURCH: 教堂效果 VOICE_BEAUTIFIER_BEDROOM: 卧室效果 VOICE_BEAUTIFIER_LIVE： Live效果 Returns: Type void Example const type = YunXinMiniappSDK.VOICE_BEAUTIFIER_MUFFLED //声音低沉 client.setVoiceBeautifierPreset(type) startAsrCaptions(sourceLang, targetLang) 加入房间后，可以开启实时字幕&amp;翻译功能 相关回调： 如果您在加入房间后调用该方法，调用成功后，本端会收到以下回调： asr-captions：字幕信息，包括字幕来源谁，字幕出发的时间戳、字幕内容、翻译内容等等 Parameters: Name Type Description sourceLang String 可选，表示讲话的原语言，需要告诉sdk说话人的语言是什么，默认为AUTO（即中英文自动识别），其他语种需要明确告知，具体参考下面列表 targetLang String 可选，表示需要翻译的语音，默认空字符串''(表示字幕不需要翻译)，其他参数参考下面列表 支持的语种如下： CN: 简体中文。 VI: 越南语。 EN: 英语。 ID: 印度尼西亚语。 IT: 意大利语。 ES: 西班牙语。 JA: 日语。 PT: 葡萄牙语。 KO: 韩语。 FR: 法语。 RU: 俄语。 DE: 德语。 AR: 阿拉伯语。 TH: 泰语。 KH: 高棉语。 LA: 老挝语。 Returns: Type Promise Example // 开启字幕&amp;翻译 import YunXinMiniappSDK from 'path/to/NERTC_Miniapp_SDK_v4.7.4.js' client = YunXinMiniappSDK.Client({ debug: true, appkey: '' }) //开启字幕，可以不填写参数 client.startAsrCaptions() stopAsrCaptions() 关闭实时字幕&amp;翻译 Parameters: Type Description Void Returns: Type Promise subscribe(uid, mediaType) 通话中，监听到stream-added事件后，如果想接收对端发送的媒体，可以调用该接口 Parameters: Name Type Description uid number 要订阅成员的uid mediaType string 要订阅的媒体类型： video: 表示订阅视频。 audio: 表示订阅音频。 screenShare: 表示订阅对端的视频辅流，即屏幕共享流 slaveAudio: 表示订阅对端的音频辅流，即（系统声卡采集的声音或者伴音等，主要是看发送端使用的什么音频流作为音频辅流） Returns: Type Promise Example // RTC流程 import YunXinMiniappSDK from 'path/to/NERTC_Miniapp_SDK_v4.7.4.js' client = YunXinMiniappSDK.Client({ debug: true, appkey: '' }) client.on('stream-added', ({uid, mediaType}) =&gt; { //mediaType的值为：audio、video、screenShare、slaveAudio console.log(`${uid} 发布了自己的 ${mediaType} 媒体能力`) client.subscribe(uid, mediaType).then(res=&gt;{ console.log(`订阅${uid} 的 ${mediaType} 成功，拉流地址: ${res.url}`) //将此url设置为live-player组件的url }) }) //当然用户可以通话中途自如的调用client.subscribe() 和 client.unsubscribe() 用于控制媒体的接收 unmute(mediaType) 一般是加入房间之后，恢复本地mute 相关回调： 如果您在加入房间后调用该方法执行unmute，调用成功后，房间里面的其他人会触发以下回调： mediaType设置为'audio'、undefined，远端触发unmute-audio回调 mediaType设置为'video'、undefined，远端触发unmute-video回调 Parameters: Name Type Description mediaType string 要恢复的媒体类型： video: 表示禁止视频。 audio: 表示禁止音频。 Returns: Type Promise Example // RTC流程 import YunXinMiniappSDK from 'path/to/NERTC_Miniapp_SDK_v4.7.4.js' client = YunXinMiniappSDK.Client({ debug: true, appkey: '' }) client.unmute('audio').then(url=&gt;{ console.log('unmute 音频成功: ', url) this.setData({ enableMic: false //设置live-pusher组件的enableMic属性为false }) }).catch(e=&gt;{ console.error('unmute 音频失败: ', e) }) unpublish(mediaType) 加入房间后，publish过自己的媒体后，可以调用该接口停止publish 相关回调： 如果执行unpublish方法，调用成功后，房间里面的其他人会触发以下回调： 远端触发stream-removed回调 Parameters: Name Type Description mediaType string 要停止发布的媒体类型： undefined：(默认) 表示停止发布音视频。 video: 表示停止发布视频。 audio: 表示停止发布音频。 Returns: Type Promise Example client.unpublish('audio').then(()=&gt;{ console.log('关闭mic成功') this.setData({ enableMic: false //设置live-pusher组件的enableMic属性为false，停止推流 }) }).catch(e=&gt;{ console.error('关闭mic失败: ', e) }) unsubscribe(uid, mediaType) 通话中，在订阅过别人之后，如果不想在接收对端发送的媒体，可以调用该接口 Parameters: Name Type Description uid number 要取消订阅成员的uid mediaType string 要取消订阅的媒体类型： video: 表示取消订阅视频。 audio: 表示取消订阅音频。 screenShare: 表示取订阅对端的屏幕共享流 slaveAudio: 表示取消订阅对端的音频辅流 Returns: Type Promise Example // RTC流程 client.unsubscribe(uid, 'audio').then(res=&gt;{ console.log('取消订阅audio 完成: ', uid) }) updateTasks(options) 更新推流任务 Parameters: Name Type Description options Object Properties Name Type Description rtmpTasks Array 推流任务队列，数组类型 Returns: Type Promise Example let rtmpTasks = [] // taskID 可选字母、数字，下划线，不超过64位（原推流任务taskId） let updatTaskId = taskId // 更新推互动直播推流地址 let streamUrl = 'rtmp://xxxxxx-1' // 更新互动直播录制 let record = true //选填，指定大画面uid let hostUid = 100 let task1 = { taskId， streamUrl, record, hostUid, // 整体布局参数 layout: { canvas: { //整体布局宽度 width: 1280, //整体布局高度 height: 720, //整体布局背景色（转为10进制的数，如：#FFFFFF 16进制转为10进制为 16777215） color: 16777215 }, users: [{ uid: 100, //用户id x: 0, // user1 的视频布局x偏移，相对整体布局的左上角（前提是推流发布user1的视频） y: 0, // user1 的视频布局y偏移，相对整体布局的左上角（前提是推流发布user1的视频） width: 640, // user1 的视频布局宽度（前提是推流发布user1的视频） height: 360, //user1 的视频布局高度（前提是推流发布user1的视频） adaption: 1, //自适应，值默认为1 pushAudio: true, // 推流是否发布user1 的音频 pushVideo: true // 推流是否发布user1的视频 }, { uid: 200, //用户id x: 0, // user2 的视频布局x偏移，相对整体布局的左上角（前提是推流发布user2的视频） y: 0, // user2 的视频布局y偏移，相对整体布局的左上角（前提是推流发布user2的视频） width: 640, // user2 的视频布局宽度（前提是推流发布user2的视频） height: 360, //user2 的视频布局高度（前提是推流发布user2的视频） adaption: 1, //自适应，值默认为1 pushAudio: true, // 推流是否发布user2 的音频 pushVideo: true // 推流是否发布user2 的视频 }], images: [{ url: \"xxxxxx\", //设置背景图片 x: 0, // 背景图片x偏移，相对整体布局的左上角 y: 0, // 背景图片y偏移，相对整体布局的左上角 width: 480, // 背景图片宽度 height: 360, //背景图片高度 adaption: 1 //自适应，值默认为1 }] }, //音视频属性的一些设置，可以不配置该内容（即task1不包括config字段） config： { audioParam: { 可以不配置该内容（即config不包括audioParam字段） bitRate: 64, //自定义音频比特率。取值范围为 10～192。语音场景建议64以上，音乐场景建议128。 channels: 2, //音频推流声道数。可以设置为1（mono）或者2（stereo）。默认为2。 codecProfile: 0, //音频编码规格。可以设置为以下值。0: 表示基本音频编码规格(默认), 1: 表示高效音频编码规格 sampleRate：48000, //音频推流采样率。可以设置为以下值: 32000, 44100, 48000（默认） singleVideoNoTrans: false //单视频直推不转码。开启后推流服务器会透传用户的视频编码，不再对视频做转码。 }, } //扩展的推流任务属性, 可以不配置该内容（即task1不包括extraInfo字段） extraInfo: '' } rtmpTasks.push(task1) // 更新推流任务 client.updateTasks({rtmpTasks}).then(()=&gt;{ console.log('更新推流任务接口成功') }).catch(error=&gt;{ console.warn('更新推流任务接口失败: ', error) }) × Search results Close Documentation generated by JSDoc 3.6.11 on 2025-08-18T17:38:56+08:00 using the DocStrap template. "},"YunXinMiniappSDK.html":{"id":"YunXinMiniappSDK.html","title":"Class: YunXinMiniappSDK","body":" Documentation Classes ClientYunXinMiniappSDK Class: YunXinMiniappSDK YunXinMiniappSDK new YunXinMiniappSDK() SDK自身暴露的接口对象 Methods Client(options) 此接口为单例模式，获取音视频操作实例 Parameters: Name Type Description options Object 初始配置项 Properties Name Type Description debug Boolean 是否开启调试, 如果开启调试, 将会在控制台输出一些log。默认false不输出日志, 可以传true来开启日志。 appkey String 实例的应用ID。 Returns: 小程序音视频操作实例对象 Type Object Example // RTC流程 import YunXinMiniappSDK from 'path/to/NERTC_Miniapp_SDK_v4.7.4.js' const client = YunXinMiniappSDK.Client({ debug: true, appkey: '' }) destroy() 清除类引用 Parameters: Type Description Void Returns: Type Void × Search results Close Documentation generated by JSDoc 3.6.11 on 2025-08-18T17:38:56+08:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
