<!--keywords: 质量监测,质量数据回调,网络状态,统计数据 -->
在通话场景中，开发者经常需要了解当前通话的通话质量、设备状态等信息，监测通话的整体体验；也可将部分质量数据在 UI 层面展示给用户，使用户能够及时了解当前通话的整体质量。NERTC SDK 支持将关键的音视频状况、网络状况、设备状态的相关指标实时回调给 APP 应用层，应用层可以将收到的数据进行展示或统计。

例如，在进行多人连麦时，您可以展示用户的实时网络质量，如下图所示。

<img style="width:400px" src=" https://yx-web-nosdn.netease.im/common/bc9cb52f00e1948491c5666d6db5c5c0/网络显示.png " alt="文本">

## <span id="功能介绍">功能介绍</span>

NERTC SDK 提供注册质量监测观测器 [`NERtcStatsObserver`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html) 的接口与相关回调方法，支持在通话中实时同步并返回质量数据，包括上下行网络质量、本地通话统计信息、本地和远端的音视频流统计信息等。

## <span id="示例项目">示例项目</span>

网易云信提供 [MediaStats 示例项目源码](https://github.com/netease-im/Advanced-Video/tree/master/MediaStats/MediaStats-Android-Java)，您可以参考该源码实现通话中质量监测。

## <span id="实现方法">实现方法</span>

调用 [`setStatsObserver`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#ac4b889a0fda28a78d7546ea4a7855162) 方法注册质量观测器，主动设置相应回调，回调名称与返回的质量数据信息的对应关系如下表所示。

| 回调 | 统计信息 |
| -- | -- |
| <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a1fa715c7c89399ab1c022ab881d62043" target="_blank">`onNetworkQuality`</a> | [上下行网络质量同步](#上下行网络质量同步) |
| <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#ae8e3b98c1ed098420ca24ca05246ee9b" target="_blank">`onRtcStats`</a> | [统计信息同步](#统计信息同步) |
| <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a863ad60c810a488e3bf0081f751c061d" target="_blank">`onLocalAudioStats`</a>、<a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a8653a1c70ebc5c899b68180a7704448f" target="_blank">`onRemoteAudioStats`</a> | [音频质量同步](#音频质量同步) |
| <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a4f862eef4f83362c623bd8946ae259b9" target="_blank">`onLocalVideoStats`</a>、<a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a20d617715d2fc6454ae989ad33e52c36" target="_blank">`onRemoteVideoStats`</a> | [视频质量同步](#视频质量同步) |

::: note note
若您需要关闭质量监测功能，再次调用此方法并传入 `null` 即可。
:::

**示例代码**如下：

**完整实现示例（包含 UI 更新）**

```java
public class QualityMonitoringActivity extends Activity implements NERtcStatsObserver {
    private static final String TAG = "QualityMonitor";
    private static final float M_SIZE = 1024f * 1024f;

    // UI 组件引用
    private TextView systemStats;      // 系统统计信息（CPU、内存、网络等）
    private TextView videoSendStats;    // 视频发送统计
    private TextView videoRecvStats;    // 视频接收统计
    private TextView audioSendStats;    // 音频发送统计
    private TextView audioRecvStats;    // 音频接收统计
    private TextView networkSendStats;  // 本地网络质量
    private TextView networkRecvStats;  // 远端网络质量

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_quality_monitoring);

        // 初始化 UI 组件
        initViews();

        // 在加入房间前注册质量观测器
        NERtcEx.getInstance().setStatsObserver(this);

        // 加入房间等后续操作...
    }

    private void initViews() {
       //...初始化 UI 组件
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 退出房间或销毁页面时取消注册
        NERtcEx.getInstance().setStatsObserver(null);
    }

    // ========== NERtcStatsObserver 回调实现 ==========

    /**
     * 本地通话统计信息回调
     * 包含通话时长、房间人数、CPU 使用率、内存使用率、收发字节数、网络延迟、丢包率等
     */
    @Override
    public void onRtcStats(NERtcStats stats) {
        // 注意：此回调在 SDK 的 worker 线程执行，若需更新 UI，需切换到主线程
        String text = String.format(Locale.CHINA,
                "tx: %.2f MB\n" +           // 累计发送字节数
                "rx: %.2f MB\n" +           // 累计接收字节数
                "cpuApp: %d%%\n" +          // 应用 CPU 使用率
                "cpuTotal: %d%%\n" +        // 系统 CPU 使用率
                "upRtt: %d ms\n" +          // 上行网络往返时延
                "downRtt: %d ms",           // 下行网络往返时延
                stats.txBytes / M_SIZE,
                stats.rxBytes / M_SIZE,
                stats.cpuAppUsage,
                stats.cpuTotalUsage,
                stats.upRtt,
                stats.downRtt);

        // 更新 UI（建议使用 Handler 或 runOnUiThread）
        runOnUiThread(() -> systemStats.setText(text));
    }

    /**
     * 本地音频流统计信息回调
     * 包含音频采样率、码率、音量、丢包率、RTT 等
     */
    @Override
    public void onLocalAudioStats(NERtcAudioSendStats stats) {
        StringBuilder stringBuilder = new StringBuilder();

        // 遍历所有音频流（主流和辅流）
        for (NERtcAudioLayerSendStats layer : stats.audioLayers) {
            String layerText = String.format(Locale.CHINA,
                    "音频流类型: %d\n" +         // 1:主流 2:辅流
                    "发送码率: %d Kbps\n" +      // 实际发送码率
                    "音量: %d\n" +               // 发送音量 (0-100)
                    "采集音量: %d\n" +           // 采集音量 (0-100)
                    "丢包率: %d%%\n" +           // 音频丢包率
                    "RTT: %d ms",                // 往返时延
                    layer.streamType,
                    layer.kbps,
                    layer.volume,
                    layer.capVolume,
                    layer.lossRate,
                    layer.rtt);

            stringBuilder.append(layerText).append("\n");
        }

        runOnUiThread(() -> audioSendStats.setText(stringBuilder.toString()));
    }

    /**
     * 远端音频流统计信息回调
     * 包含每个远端用户的音频质量、码率、音量、丢包率、卡顿率等
     */
    @Override
    public void onRemoteAudioStats(NERtcAudioRecvStats[] statsArray) {
        if (statsArray == null || statsArray.length == 0) {
            return;
        }

        StringBuilder stringBuilder = new StringBuilder();

        // 遍历所有远端用户的音频流
        for (NERtcAudioRecvStats stats : statsArray) {
            stringBuilder.append(String.format(Locale.CHINA, "用户 uid: %d\n", stats.uid));

            // 遍历该用户的所有音频流（主流和辅流）
            for (NERtcAudioLayerRecvStats layer : stats.layers) {
                String layerText = String.format(Locale.CHINA,
                        "  音频流: %d\n" +             // 1:主流 2:辅流
                        "  接收码率: %d Kbps\n" +      // 接收码率
                        "  音量: %d\n" +               // 接收音量 (0-100)
                        "  丢包率: %d%%\n" +           // 丢包率
                        "  卡顿率: %d%%\n" +           // 音频卡顿率
                        "  卡顿时长: %d ms",           // 累计卡顿时长
                        layer.streamType,
                        layer.kbps,
                        layer.volume,
                        layer.lossRate,
                        layer.frozenRate,
                        layer.totalFrozenTime);

                stringBuilder.append(layerText).append("\n");
            }
        }

        runOnUiThread(() -> audioRecvStats.setText(stringBuilder.toString()));
    }

    /**
     * 本地视频流统计信息回调
     * 包含视频分辨率、帧率、码率、编码器类型等
     */
    @Override
    public void onLocalVideoStats(NERtcVideoSendStats stats) {
        if (stats == null || stats.videoLayers == null) {
            return;
        }

        StringBuilder stringBuilder = new StringBuilder();

        // 遍历所有视频流（主流和辅流）
        for (NERtcVideoLayerSendStats sendStats : stats.videoLayers) {
            String text = String.format(Locale.CHINA,
                    "uid: %d\n" +
                    "视频流类型: %d\n" +          // 1:主流 2:辅流
                    "采集分辨率: %dx%d\n" +       // 采集宽高
                    "编码分辨率: %dx%d\n" +       // 编码宽高
                    "采集帧率: %d fps\n" +        // 采集帧率
                    "发送帧率: %d fps\n" +        // 发送帧率
                    "编码帧率: %d fps\n" +        // 编码帧率
                    "发送码率: %d Kbps\n" +       // 实际发送码率
                    "目标码率: %d Kbps\n" +       // 目标码率
                    "编码码率: %d Kbps\n" +       // 编码器实际码率
                    "编码器: %s",                 // 编码器名称
                    NERtcEx.getInstance().getMyUid(),
                    sendStats.layerType,
                    sendStats.capWidth,
                    sendStats.capHeight,
                    sendStats.width,
                    sendStats.height,
                    sendStats.captureFrameRate,
                    sendStats.sentFrameRate,
                    sendStats.encoderOutputFrameRate,
                    sendStats.sendBitrate,
                    sendStats.targetBitrate,
                    sendStats.encoderBitrate,
                    sendStats.encoderName);

            stringBuilder.append(text).append("\n");
        }

        runOnUiThread(() -> videoSendStats.setText(stringBuilder.toString()));
    }

    /**
     * 远端视频流统计信息回调
     * 包含每个远端用户的视频分辨率、帧率、码率、丢包率、解码器类型等
     */
    @Override
    public void onRemoteVideoStats(NERtcVideoRecvStats[] statsArray) {
        if (statsArray == null || statsArray.length == 0) {
            return;
        }

        StringBuilder stringBuilder = new StringBuilder();

        // 遍历所有远端用户的视频流
        for (NERtcVideoRecvStats stats : statsArray) {
            stringBuilder.append(String.format(Locale.CHINA, "用户 uid: %d\n", stats.uid));

            // 遍历该用户的所有视频流（主流和辅流）
            for (NERtcVideoLayerRecvStats recvStats : stats.layers) {
                String text = String.format(Locale.CHINA,
                        "  视频流: %d\n" +            // 1:主流 2:辅流
                        "  分辨率: %dx%d\n" +         // 视频宽高
                        "  接收帧率: %d fps\n" +      // 接收帧率
                        "  解码帧率: %d fps\n" +      // 解码帧率
                        "  渲染帧率: %d fps\n" +      // 渲染帧率
                        "  接收码率: %d Kbps\n" +     // 接收码率
                        "  丢包率: %d%%\n" +          // 丢包率
                        "  卡顿率: %d%%\n" +          // 视频卡顿率
                        "  卡顿时长: %d ms\n" +      // 累计卡顿时长
                        "  解码器: %s",              // 解码器名称
                        recvStats.layerType,
                        recvStats.width,
                        recvStats.height,
                        recvStats.fps,
                        recvStats.decoderOutputFrameRate,
                        recvStats.rendererOutputFrameRate,
                        recvStats.receivedBitrate,
                        recvStats.packetLossRate,
                        recvStats.frozenRate,
                        recvStats.totalFrozenTime,
                        recvStats.decoderName);

                stringBuilder.append(text).append("\n");
            }
        }

        runOnUiThread(() -> videoRecvStats.setText(stringBuilder.toString()));
    }

    /**
     * 上下行网络质量回调
     * 包含房间内每个用户的上下行网络质量评分
     *
     * 网络质量等级说明：
     * - 0 (UNKNOWN): 未知
     * - 1 (EXCELLENT): 极好
     * - 2 (GOOD): 不错
     * - 3 (POOR): 一般
     * - 4 (BAD): 较差，可能卡顿
     * - 5 (VERYBAD): 非常差，无法保证质量
     * - 6 (DOWN): 无网络
     */
    @Override
    public void onNetworkQuality(NERtcNetworkQualityInfo[] statsArray) {
        if (statsArray == null || statsArray.length == 0) {
            return;
        }

        long myUid = NERtcEx.getInstance().getMyUid();

        for (NERtcNetworkQualityInfo info : statsArray) {
            String text = String.format(Locale.CHINA,
                    "用户 uid: %d\n" +
                    "上行质量: %d (%s)\n" +    // 上行网络质量
                    "下行质量: %d (%s)",         // 下行网络质量
                    info.userId,
                    info.upStatus,
                    getQualityDescription(info.upStatus),
                    info.downStatus,
                    getQualityDescription(info.downStatus));

            // 根据用户 ID 区分本地和远端网络质量
            if (info.userId == myUid) {
                // 本地网络质量
                runOnUiThread(() -> networkSendStats.setText(text));
            } else {
                // 远端网络质量
                runOnUiThread(() -> networkRecvStats.setText(text));
            }
        }
    }

    /**
     * 获取网络质量等级的文字描述
     *
     * @param quality 网络质量等级
     * @return 质量描述文字
     */
    private String getQualityDescription(int quality) {
        switch (quality) {
            case 0:
                return "未知";
            case 1:
                return "极好";
            case 2:
                return "不错";
            case 3:
                return "一般";
            case 4:
                return "较差";
            case 5:
                return "很差";
            case 6:
                return "断网";
            default:
                return "未知";
        }
    }
}
```

::: note note
**重要提示：**
1. 所有回调均在 SDK 的 worker 线程执行，如需更新 UI，请使用 `runOnUiThread()` 或 `Handler`
2. 回调间隔为 2 秒，频繁的 UI 更新可能影响性能，建议适当控制更新频率
3. 数据统计基于 2 秒的采样周期，不同时间点的数据可能存在波动
:::

**简化版示例（仅日志输出）**

```java
NERtcEx.getInstance().setStatsObserver(new NERtcStatsObserver() {
    @Override
    public void onRtcStats(NERtcStats stats) {
        // 本地通话统计：字节数、CPU 使用率、网络延迟、丢包率
        String statsStrInfo = String.format(Locale.CHINA,
                "tx:%.2fMB rx: %.2fMB v_lost:%d%% a_lost:%d%% upRtt:%d downRtt:%d",
                stats.txBytes / M_SIZE, stats.rxBytes / M_SIZE,
                stats.txVideoPacketLossRate, stats.txAudioPacketLossRate,
                stats.upRtt, stats.downRtt);
        Log.d(TAG, "onRtcStats: " + statsStrInfo);
    }

    @Override
    public void onLocalAudioStats(NERtcAudioSendStats stats) {
        // 本地音频发送统计：码率、音量、丢包率
        for (NERtcAudioLayerSendStats layer : stats.audioLayers) {
            String statsStrInfo = String.format(Locale.CHINA,
                    "audio_type:%d, kbps:%dKbps, vol:%d, cap_vol:%d, lost:%d%%, rtt:%d",
                    layer.streamType, layer.kbps, layer.volume,
                    layer.capVolume, layer.lossRate, layer.rtt);
            Log.d(TAG, "onLocalAudioStats: " + statsStrInfo);
        }
    }

    @Override
    public void onRemoteAudioStats(NERtcAudioRecvStats[] statsArray) {
        if (statsArray == null) return;

        // 远端音频接收统计
        for (NERtcAudioRecvStats stats : statsArray) {
            for (NERtcAudioLayerRecvStats layer : stats.layers) {
                String statsStrInfo = String.format(Locale.CHINA,
                        "uid:%d, audio_type:%d, kbps:%dKbps, vol:%d, lost:%d%%",
                        stats.uid, layer.streamType, layer.kbps,
                        layer.volume, layer.lossRate);
                Log.d(TAG, "onRemoteAudioStats: " + statsStrInfo);
            }
        }
    }

    @Override
    public void onLocalVideoStats(NERtcVideoSendStats stats) {
        if (stats == null) return;

        // 本地视频发送统计：分辨率、帧率、码率、编码器
        for (NERtcVideoLayerSendStats sendStats : stats.videoLayers) {
            String statsStrInfo = String.format(Locale.CHINA,
                    "video_type:%d, cap:%dx%d, send:%dx%d, fps:%d, enc_bitrate:%dKbps, send_bitrate:%dKbps, encoder:%s",
                    sendStats.layerType, sendStats.capWidth, sendStats.capHeight,
                    sendStats.width, sendStats.height, sendStats.sentFrameRate,
                    sendStats.encoderBitrate, sendStats.sendBitrate,
                    sendStats.encoderName);
            Log.d(TAG, "onLocalVideoStats: " + statsStrInfo);
        }
    }

    @Override
    public void onRemoteVideoStats(NERtcVideoRecvStats[] statsArray) {
        if (statsArray == null) return;

        // 远端视频接收统计：分辨率、帧率、码率、丢包率、解码器
        for (NERtcVideoRecvStats stats : statsArray) {
            for (NERtcVideoLayerRecvStats recvStats : stats.layers) {
                String statsStrInfo = String.format(Locale.CHINA,
                        "uid:%d, video_type:%d, res:%dx%d, fps:%d, bitrate:%dKbps, lost:%d%%, decoder:%s",
                        stats.uid, recvStats.layerType, recvStats.width, recvStats.height,
                        recvStats.fps, recvStats.receivedBitrate,
                        recvStats.packetLossRate, recvStats.decoderName);
                Log.d(TAG, "onRemoteVideoStats: " + statsStrInfo);
            }
        }
    }

    @Override
    public void onNetworkQuality(NERtcNetworkQualityInfo[] statsArray) {
        if (statsArray == null) return;

        // 上下行网络质量
        for (NERtcNetworkQualityInfo info : statsArray) {
            String statsStrInfo = String.format(Locale.CHINA,
                    "uid:%d, up:%d, down:%d",
                    info.userId, info.upStatus, info.downStatus);
            Log.d(TAG, "onNetworkQuality: " + statsStrInfo);
        }
    }
});
```

## 质量数据分析与优化建议

### <span id="网络质量评估标准">网络质量评估标准</span>

网络质量等级对应的实际情况及优化建议如下表所示：

| 网络质量等级 | 数值 | 典型特征 | 优化建议 |
| -- | -- | -- | -- |
| **EXCELLENT** | 1 | 网络极好，画质清晰，声音流畅 | 无需优化 |
| **GOOD** | 2 | 网络不错，偶有轻微波动 | 正常状态，可适当提升视频参数 |
| **POOR** | 3 | 网络一般，可能出现轻微卡顿 | 建议降低视频分辨率或码率 |
| **BAD** | 4 | 网络较差，明显卡顿 | 建议切换至网络质量更好的环境，或大幅降低视频参数 |
| **VERYBAD** | 5 | 网络很差，严重影响通话 | 建议切换至 4G/5G 或 WiFi 环境 |
| **DOWN** | 6 | 无网络连接 | 检查网络连接状态 |

### <span id="关键指标监控">关键指标监控</span>

建议重点关注以下关键指标，及时发现和解决通话质量问题：

#### 网络层指标
- **丢包率 (packetLossRate)**
  - 音频丢包率 < 5%：正常
  - 音频丢包率 5%-10%：轻微影响
  - 音频丢包率 > 10%：需要优化
  - 视频丢包率 < 3%：正常
  - 视频丢包率 3%-10%：轻微影响
  - 视频丢包率 > 10%：需要优化

- **往返时延 (RTT)**
  - RTT < 100ms：优秀
  - RTT 100-300ms：良好
  - RTT 300-500ms：一般
  - RTT > 500ms：较差

- **抖动**
  - 抖动 < 30ms：优秀
  - 抖动 30-50ms：良好
  - 抖动 50-100ms：一般
  - 抖动 > 100ms：较差

#### 音频质量指标
- **码率 (kbps)**：保证音频清晰度，建议保持在 32-64 Kbps
- **音量 (volume)**：发送音量建议在 40-80 之间，避免过大或过小
- **卡顿率 (frozenRate)**：音频卡顿率应控制在 5% 以下

#### 视频质量指标
- **分辨率 (width x height)**：根据网络状况动态调整
- **帧率 (fps)**：建议保持在 15-30 fps
- **码率 (bitrate)**：根据分辨率和帧率合理设置
- **卡顿率 (frozenRate)**：视频卡顿率应控制在 3% 以下

### <span id="常见问题诊断">常见问题诊断</span>

#### 问题 1：视频卡顿严重
**可能原因：**
- 网络质量差（丢包率高、延迟大）
- 上行带宽不足
- 设备性能不足

**解决方案：**
1. 降低视频分辨率：从 720p 降至 480p 或更低
2. 降低帧率：从 30fps 降至 15fps
3. 降低目标码率
4. 开启视频降噪或清晰度优先模式
5. 检查设备 CPU 使用率，如过高可关闭其他应用

**示例代码：**
```java
// 动态调整视频参数
private void adjustVideoQuality(int networkQuality) {
    NERtcVideoConfig config = new NERtcVideoConfig();

    switch (networkQuality) {
        case 1:  // EXCELLENT - 极好
            config.videoProfile = NERtcVideoProfile.HD720P;
            break;
        case 2:  // GOOD - 不错
            config.videoProfile = NERtcVideoProfile.HD720P;
            break;
        case 3:  // POOR - 一般
            config.videoProfile = NERtcVideoProfile.STANDARD480P;
            break;
        case 4:  // BAD - 较差
        case 5:  // VERYBAD - 很差
            config.videoProfile = NERtcVideoProfile.LOWEST360P;
            break;
    }

    NERtcEx.getInstance().setLocalVideoConfig(config);
}
```

#### 问题 2：CPU 占用过高
**可能原因：**
- 视频分辨率和帧率过高
- 同时开启多种编码器
- 设备性能不足

**解决方案：**
1. 降低视频分辨率和帧率
2. 使用硬件编码器（如 H.264 硬编）
3. 关闭不必要的功能（如美颜、特效）
4. 优化应用其他模块的 CPU 使用

### <span id="最佳实践">最佳实践</span>

1. **在合适的时机注册/注销观察器**
   - 在 `onCreate` 或加入房间前注册
   - 在 `onDestroy` 或离开房间后注销

2. **线程安全处理**
   - 所有回调均在 worker 线程执行
   - UI 更新必须通过 `runOnUiThread()` 或 `Handler` 切换到主线程

3. **合理控制数据更新频率**
   - 回调间隔为 2 秒，建议 UI 更新频率不超过 1 秒
   - 避免在回调中进行耗时操作

4. **异常处理**
   - 检查回调参数是否为 null
   - 捕获并处理可能的异常
   - 提供友好的错误提示

5. **性能优化**
   - 避免频繁的字符串拼接，使用 `StringBuilder`
   - 适当缓存 UI 组件引用
   - 合理使用日志级别

6. **用户体验优化**
   - 根据网络质量动态调整视频参数
   - 提供清晰的质量提示信息
   - 在网络恢复后自动提升画质

## 相关回调的详细说明
### <span id="上下行网络质量同步">上下行网络质量同步</span>

[**`onNetworkQuality`**](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a1fa715c7c89399ab1c022ab881d62043) 回调以数组的形式向您同步当前通话中每个成员的上下行网络质量。
- 上行网络质量打分基于实际发送码率、上行网络丢包率、平均往返时延和上行网络抖动计算。
- 下行网络质量打分基于下行网络丢包率、平均往返时延和下行网络抖动计算。

::: note note
- 每隔 2 秒您会收到房间内所有用户的网络质量同步。
- 实际发送码率与目标发送码率的比值越高，该网络下的通话质量越好，该网络质量打分越高。
:::

[**`NERtcNetworkQualityInfo`**](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_network_quality_info.html) 数组中各参数的说明如下表所示。

<table>
<tr>
    <th width="30%">参数</th>
    <th width="70%">参数说明</th>
</tr>
    <tr>
    <td>userId</td>
    <td>用户 ID，指定是哪个用户的网络质量统计。</td>
</tr>
    <tr>
    <td>upStatus</td>
    <td>该用户的上行网络质量。</td>
</tr>
    <tr>
    <td>downStatus</td>
    <td>该用户的下行网络质量。</td>
</tr>
</table>

其中网络质量以网络状态的好坏衡量，[**`NetworkStatus`**](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_constants_1_1_network_status.html) 的各枚举值如下表所示。

<table>
<tr>
    <th width="30%">枚举值</th>
    <th width="70%">说明</th>
</tr>
    <tr>
    <td>UNKNOWN（0）</td>
    <td>当前网络状态未知。</td>
</tr>
    <tr>
    <td>EXCELLENT（1）</td>
    <td>当前网络状态极好。</td>
</tr>
    <tr>
    <td>GOOD（2）</td>
    <td>当前网络状态不错。</td>
</tr>
    <tr>
    <td>POOR（3）</td>
    <td>当前网络状态一般。</td>
</tr>
    <tr>
    <td>BAD（4）</td>
    <td>当前网络状态比较差，可能出现卡顿和网络延迟。</td>
</tr>
    <tr>
    <td>VERYBAD（5）</td>
    <td>当前网络状态非常差，无法保证正常的通话质量。</td>
</tr>
    <tr>
    <td>DOWN（6）</td>
    <td>当前无网络。</td>
</tr>
</table>


### <span id="统计信息同步">统计信息同步</span>

[**`onRtcStats`**](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#ae8e3b98c1ed098420ca24ca05246ee9b) 回调向您同步本地通话统计信息。其中包含通话时长、当前通话房间中的人数、当前系统的 CPU 使用率、当前 App 的 CPU 使用率等重要数据。

<table>
<tr>
    <th width="30%">参数</th>
    <th width="70%">参数说明</th>
</tr>
    <tr>
        <td>cpuAppUsage、cpuTotalUsage</td>
        <td>App 的 CPU 使用率和系统的 CPU 使用率。</td>
    </tr>
    <tr>
        <td>memoryAppUsageRatio、memoryAppUsageInKBytes、memoryTotalUsageRatio</td>
        <td>App 的内存使用率、内存使用量、系统的内存使用率。</td>
    </tr>
    <tr>
        <td>totalDuration</td>
        <td>通话总时长，单位为秒。</td>
    </tr>
    <tr>
        <td>txBytes/rxBytes</td>
        <td>累计发送/接收字节数。</td>
    </tr>
    <tr>
        <td>txAudioBytes/rxAudioBytes</td>
        <td>音频发送/接收字节数。</td>
    </tr>
    <tr>
        <td>txVideoBytes/rxVideoBytes</td>
        <td>视频发送/接收字节数。</td>
    </tr>
    <tr>
        <td>txAudioKBitRate/rxAudioKBitRate</td>
        <td>音频接收/发送码率，单位为 Kbps。</td>
    </tr>
    <tr>
        <td>txVideoKBitRate/rxVideoKBitRate</td>
        <td>视频接收/发送码率，单位为 Kbps。</td>
    </tr>
    <tr>
        <td>upRtt/downRtt</td>
        <td>上行/下行平均往返时延，单位为毫秒。</td>
    </tr>
    <tr>
        <td>txAudioPacketLossRate/rxAudioPacketLossRate</td>
        <td>本地上行/下行音频实际丢包率。</td>
    </tr>
    <tr>
        <td>txAudioPacketLossSum/rxAudioPacketLossSum</td>
        <td>本地上行/下行音频实际丢包数。</td>
    </tr>
    <tr>
        <td>txAudioJitter/rxAudioJitter</td>
        <td>本地上行/下行音频抖动计算，单位为毫秒。</td>
    </tr>
    <tr>
        <td>txVideoJitter/rxVideoJitter</td>
        <td>本地上行/下行视频抖动计算，单位为毫秒。</td>
    </tr>
    <tr>
        <td>txVideoPacketLossRate/rxVideoPacketLossRate</td>
        <td>本地上行/下行视频实际丢包率。</td>
    </tr>
    <tr>
        <td>txVideoPacketLossSum/rxVideoPacketLossSum</td>
        <td>本地上行/下行视频实际丢包数。</td>
    </tr>
</table>

### <span id="音频质量同步">音频质量同步</span>

**本地音频流统计信息同步**

[**`onLocalAudioStats`**](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a863ad60c810a488e3bf0081f751c061d) 回调向您同步本地设备发送音频流的统计信息，包括当前通话声道数（单声道或双声道）、发送音频的采样率和发送音频的码率。SDK 会每隔 2 秒自动触发本回调。

<table>
    <tr>
        <th width="20%"><b>参数</b></th>
        <th width="40%"><b>参数说明</b></th>
    </tr>
    <tr>
        <td>numChannels</td>
        <td>当前采集的声道数。</td>
    </tr>
    <tr>
        <td>sentSampleRate</td>
        <td>统计周期内本地上行音频采样率，单位为 Hz。</td>
    </tr>
    <tr>
        <td>kbps</td>
        <td>统计周期内发送码率的平均值，单位为 Kbps。</td>
    </tr>
    <tr>
        <td>lossRate</td>
        <td>特定时间内的音频丢包率。</td>
    </tr>
    <tr>
        <td>rtt</td>
        <td>平均往返时延（RTT）。</td>
    </tr>
    <tr>
        <td>volume</td>
        <td>音量，取值范围为 0 ~ 100。</td>
    </tr>
</table>

**远端音频流统计信息同步**

[**`onRemoteAudioStats`**](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a8653a1c70ebc5c899b68180a7704448f) 回调向您同步当前通话中每个远端用户音频流的统计信息，包括每个远端用户发送的音频流质量、声道数等信息。SDK 会每隔 2 秒自动触发本回调。

<table>
    <tbody>
        <tr>
            <td width="20%"><strong>参数</strong></td>
            <td width="40%"><strong>参数说明</strong></td>
        </tr>
        <tr>
            <td>uid</td>
            <td>用户 ID，指定是哪个用户的音频流。</td>
        </tr>
        <tr>
            <td>kbps</td>
            <td>统计周期内接收到的码率平均值，单位为 Kbps。</td>
        </tr>
        <tr>
            <td>totalFrozenTime</td>
            <td>远端用户在加入房间后发生音频卡顿的累计时长，单位为毫秒。一个统计周期内，音频丢帧率达到 4% 即记为一次音频卡顿。</td>
        </tr>
        <tr>
            <td>frozenRate</td>
            <td>远端用户下行音频平均卡顿率。其值为远端用户在加入房间后发生音频卡顿的累计时长占音频总有效时长的百分比。</td>
        </tr>
        <tr>
            <td>lossRate</td>
            <td>统计周期内的远端音频流的丢帧率。</td>
        </tr>
        <tr>
            <td>volume</td>
            <td>音量，取值范围为 0 ~ 100。</td>
        </tr>
    </tbody>
</table>

### <span id="视频质量同步">视频质量同步</span>

**本地视频流统计信息同步**

[**`onLocalVideoStats`**](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a4f862eef4f83362c623bd8946ae259b9) 回调向您同步本地设备发送视频流的统计信息，包括视频编码宽/高等信息。SDK 会每隔 2 秒自动触发本回调。

如果您此前调用 [`enableDualStreamMode`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#ac9ee4b883d6cdecc2990a43527f8be86) 方法开启了双流模式，则本回调描述本地设备发送的视频大流的统计信息。

<table>
    <tbody>
        <tr>
            <td width="20%"><strong>参数</strong></td>
            <td width="40%"><strong>参数说明</strong></td>
        </tr>
        <tr>
            <td>layerType</td>
            <td>视频流通道类型。<li>1：主流。<li>2：辅流。</td>
        </tr>
        <tr>
            <td>width</td>
            <td>视频编码宽度，单位为 px。</td>
        </tr>
        <tr>
            <td>height</td>
            <td>视频编码高度，单位为 px。</td>
        </tr>
        <tr>
            <td>captureFrameRate</td>
            <td>视频采集帧率，单位为 fps。</td>
        </tr>
        <tr>
            <td>renderFrameRate</td>
            <td>视频渲染帧率，单位为 fps。</td>
        </tr>
        <tr>
            <td>encoderOutputFrameRate</td>
            <td>编码帧率，单位为 fps。</td>
        </tr>
        <tr>
            <td>sentFrameRate</td>
            <td>实际发送帧率，单位为 fps，不包含丢包后重传视频等的发送帧率。</td>
        </tr>
        <tr>
            <td>sendBitrate</td>
            <td>实际发送码率，单位为 Kbps，不包含丢包后重传视频等的发送码率。</td>
        </tr>
        <tr>
            <td>targetBitrate</td>
            <td>当前编码器的目标编码码率，单位为 Kbps，该码率为 SDK 根据当前网络状况预估的一个值。</td>
        </tr>
        <tr>
            <td>encoderBitrate</td>
            <td>编码器实际编码码率，单位为 Kbps。</td>
        </tr>
        <tr>
            <td>encoderName</td>
            <td>视频编码器的名称。</td>
        </tr>
    </tbody>
</table>

**远端视频流统计信息同步**

[**`onRemoteVideoStats`**](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1stats_1_1_n_e_rtc_stats_observer.html#a20d617715d2fc6454ae989ad33e52c36) 回调向您同步当前通话中每个远端用户/主播的视频流的统计信息，包括每个远端用户的视频宽/高等参数信息。SDK 会每隔 2 秒自动触发本回调。

<table>
    <tbody>
        <tr>
            <td width="20%"><strong>参数</strong></td>
            <td width="40%"><strong>参数说明</strong></td>
        </tr>
        <tr>
            <td>layerType</td>
            <td>视频流通道类型。<li>1：主流。<li>2：辅流。</td>
        </tr>
        <tr>
            <td>width</td>
            <td>远端视频编码宽度，单位为 px。</td>
        </tr>
        <tr>
            <td>height</td>
            <td>远端视频编码高度，单位为 px。</td>
        </tr>
        <tr>
            <td>receivedBitrate</td>
            <td>接收到的码率，单位为 Kbps。</td>
        </tr>
        <tr>
            <td>fps</td>
            <td>接收到的帧率，单位为 fps。</td>
        </tr>
        <tr>
            <td>decoderOutputFrameRate</td>
            <td>解码帧率，单位为 fps。</td>
        </tr>
        <tr>
            <td>rendererOutputFrameRate</td>
            <td>渲染帧率，单位为 fps。</td>
        </tr>
        <tr>
            <td>packetLossRate</td>
            <td>远端视频下行丢包率。</td>
        </tr>
        <tr>
            <td>totalFrozenTime</td>
            <td>远端用户加入房间后，其下行视频卡顿累计时长，单位为毫秒。</td>
        </tr>
        <tr>
            <td>frozenRate</td>
            <td>远端用户加入房间后，其下行视频平均卡顿率，其值为视频卡顿的累计时长占视频总有效时长的百分比。</td>
        </tr>
        <tr>
            <td>decoderName</td>
            <td>视频编码器的名称。</td>
        </tr>
    </tbody>
</table>
