在金融行业等对用户隐私数据要求较高的行业场景中，往往需要额外采用媒体流加密方式保障用户数据在网络传输过程中的安全性、保障用户的信息安全和数据安全。网易云信在默认加密算法的基础上，提供了内置国密加密和自定义加密方案，进一步保障数据安全。

## 功能介绍

媒体流加密指在音视频流传输过程中对音视频数据进行加密，网易云信提供以下两种加密方式。

- 内置国密加密：使用 NERTC SDK 预置的国密加密模式给媒体流加密。
- 自定义加密：通过 NERTC SDK 提供的数据包观测器来自定义媒体流的加密模式。网易云信服务器可以对自定义加密后的媒体流进行传输，加解密均在客户端完成。

## 注意事项

- 您只可选择 SDK 内置的国密加密算法或自定义加密算法，两种加密算法不可同时使用，否则会报错 `ENGINE_ERROR_INVALID_STATE（30005）`。
- 同一房间内，所有调用 [enableEncryption](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a4debf8b1f096ce1314e8bc055b7dd0b3) 方法开启媒体流加密的用户必须使用相同的加密模式、密钥等，否则加入房间时会报错 `ENGINE_ERROR_ENCRYPT_NOT_SUITABLE（30113）`。

**内置加密的注意事项：**

- 安全起见，若您选择 SDK 内置加密算法，建议每次启用媒体流加密时都更换新的密钥。


**自定义加密的注意事项：**

- 由于自定义媒体流加密对设备性能要求较高，建议您准备好以下开发环境：
    - 可支持的安卓设备包括：高通骁龙 636、MTK  6762、海思 kirin659、三星 Exynos 7420 及以上（其他品牌请参考同等 CPU 价位）。
    - 安卓系统版本要求 Android 8.0 及以上。
- 密钥等参数均由您自己的服务器进行分发。

- 若您选择自定义加密，请在创建房间前注册自定义加密对象，该房间的属性为“自定义加密房间”。后续用户必须也启用自定义加密才可成功加入，否则加入房间时会报错 `ENGINE_ERROR_ENCRYPT_NOT_SUITABLE（30113）` 。

- 加入“自定义加密房间”的双方若使用了不同的自定义加密算法，会强行进行加解密，会导致视频画面绿屏，音频机械音。

- 若要在某个 RTC 音视频通话房间中启用自定义加密，则必须保证加入房间的用户，使用 v4.6.53 及以上版本的 SDK（V5.3 版本不支持），且仅限 iOS、Android、Windows、macOS 和 Web 五个端，不支持小程序、Sip、Linux等其他平台客户端加入“自定义加密房间”。
- 使用了自定义加密的 RTC 音视频通话房间，不支持使用云端录制、云端播放、旁路推流等媒体服务，不支持安全通服务，不支持服务端本地录制服务。


## 示例项目源码
网易云信提供[媒体流加密的示例项目源码 MediaEncryption ](https://github.com/netease-im/G2-API-Examples/tree/main/android/Advance/MediaEncryption)，您可以参考该源码实现媒体流加密。

## 开通媒体流加密

1. 登录<a href="https://app.yunxin.163.com/index#/" target="_blank">网易云信控制台</a>。

2. 在首页单击指定应用名称。
3. 在**产品总览**区域，单击**音视频通话 2.0** 产品选项卡中的**功能配置**。


    ![功能配置.png](https://yx-web-nosdn.netease.im/common/50fdee5139f9e30204445b9386f205cd/功能配置.png)



4. 单击**高级功能**页签，单击 **音视频媒体流加密** 的开关按钮，开启媒体流加密。


    ![开通媒体流加密.png](https://yx-web-nosdn.netease.im/common/fae25d4ed33e0eeb7777f09d1fed3a51/开通媒体流加密.png)


5. 单击**确定**。

## 内置加密

### 功能原理
![内置加密.png](https://yx-web-nosdn.netease.im/common/78718e990a3fdeb0ec80504a4ebfcac5/内置加密.png)

<br>**启用内置国密加密的实现步骤**：
1. 您的服务端生成密钥并加密传输给客户端。
2. 用户 A 采集音视频流之后，通过 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a4debf8b1f096ce1314e8bc055b7dd0b3) 其中EncryptionMode选择GMCryptoSM4ECB，启用加密并传入加密模式和密钥，SDK 会用您选择的加密算法对音视频流进行加密，并将加密后的音视频流传输到网易云信音视频服务。
3. 网易云信音视频服务中转加密的音视频流。
4. 用户 B 收到音视频流之后，通过 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a4debf8b1f096ce1314e8bc055b7dd0b3) 其中EncryptionMode选择GMCryptoSM4ECB，传入相同的加密模式和密钥，SDK 会使用同样的加密算法和密钥对媒体流解密，并解码与渲染。

### 配置步骤

1. 在您的服务端生成密钥。参考以下命令通过 OpenSSL 随机生成 String 型、16 字节的密钥。

```
// 随机生成一个 string 型、16 字节的密钥，并将该密钥传入 `enableEncryption` 的 `config` 参数。
openssl rand -hex 16dba643c8ba6b6dc738df43d9fd624293b4b12d87a60f518253bd10ba98c48453
```

2. 客户端从服务端获取 String 型密钥，并在加入房间前调用 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a4debf8b1f096ce1314e8bc055b7dd0b3) 方法开启媒体流加密功能，设置媒体加密模式为 `GMCryptoSM4ECB`，并在 `config` 的 `key` 参数中传入密钥。

::: note note
- 加密模式目前仅支持国密 SM4 对称加密算法。
- 密钥由服务端生成，格式为 String 类型的字符串。
:::

### 示例代码

```
// enable , before joinChannel
NERtcEncryptionConfig encryptionConfig = new NERtcEncryptionConfig(NERtcEncryptionConfig.EncryptionMode.GMCryptoSM4ECB, gmEncryptKey, null);
NERtcEx.getInstance().enableEncryption(true,encryptionConfig);

//disable (default option), before joinChannel
NERtcEncryptionConfig encryptionConfig = new NERtcEncryptionConfig(NERtcEncryptionConfig.EncryptionMode.GMCryptoSM4ECB, null, null);
NERtcEx.getInstance().enableEncryption(false, encryptionConfig);
```



## 自定义加密

### 功能原理

![自定义加密.png](https://yx-web-nosdn.netease.im/common/b3d3177c29f1d8d571ff42e10c648fdf/自定义加密.png)
<br>**启用自定义加密的实现步骤**：
1. 您的服务端生成密钥并加密传输给客户端。
2. 用户 A 采集音视频流之后，借助返回的音视频数据的缓存地址等信息启用自定义加密，SDK 会将加密后的音视频流传输到网易云信音视频服务。
3. 网易云信音视频服务中转加密的音视频流。
4. 用户 B 收到音视频流之后，借助返回的音视频数据的缓存地址等信息启用自定义解密，选择和用户 A 相同的加密算法对媒体流解密，SDK 会将解密后的媒体流进行解码与渲染。

### 配置步骤

用户 A 采集音视频流之后，通过 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a4debf8b1f096ce1314e8bc055b7dd0b3) 方法，并注册 [`NERtcPacketObserver`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/V4.6.53/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1encryption_1_1_n_e_rtc_packet_observer.html)  监听自定义加密回调，实现自定义加密功能。参考步骤如下：

1. 遵循 NERtcEnginePacketObserver 协议实现  [`NERtcPacketObserver`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/V4.6.53/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1encryption_1_1_n_e_rtc_packet_observer.html) 自定义加密观察对象类，帮助您通过回调的音视频包相关参数进行自定义加密处理。
2. 在初始化后加入房间前，调用 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a4debf8b1f096ce1314e8bc055b7dd0b3) 开启媒体流加密功能，设置媒体加密模式为 `NERtcEncryptionModeCustom` ， 在 `observer` 参数中传入第一步中实现的观察对象，注册数据包观测器，监听数据包采集回调。
3. 加入房间后通过 `onSendAudioPacket` 和 `onSendVideoPacket` 回调的 `packet` 参数进行自定义加密，或通过 `onReceiveAudioPacket`和`onReceiveVideoPacket`回调的 `packet` 参数进行自定义解密。
4. 若您想取消自定义加密，请在离开房间后调用  [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a4debf8b1f096ce1314e8bc055b7dd0b3) 方法，并将 `enable` 参数设置为 `false`。



### 示例代码

```
//step1:定义Cipher
private Cipher audioPktEncoder = Cipher.getInstance("AES/GCM/NoPadding");
byte[] audioIv = new byte[12];
audioPktEncoder.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(gmEncryptKey.getBytes(), "AES"), new GCMParameterSpec(128, audioIv));
private Cipher videoPktEncoder = Cipher.getInstance("AES/GCM/NoPadding");
byte[] videoIv = new byte[12];
videoPktEncoder.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(gmEncryptKey.getBytes(), "AES"), new GCMParameterSpec(128, videoIv));
private Cipher audioPktDecoder = Cipher.getInstance("AES/GCM/NoPadding");
audioPktDecoder.init(Cipher.DECRYPT_MODE, new SecretKeySpec(gmEncryptKey.getBytes(), "AES"), new GCMParameterSpec(128, audioIv));
private Cipher videoPktDecoder = Cipher.getInstance("AES/GCM/NoPadding");
videoPktDecoder.init(Cipher.DECRYPT_MODE, new SecretKeySpec(gmEncryptKey.getBytes(), "AES"), new GCMParameterSpec(128, videoIv));

//step2:初始化引擎。
NERtcEx.getInstance().init(Context context, String appkey, NERtcCallback callback, NERtcOption option);

//step3:准备如下自定义加解密类，需要实现NERtcPacketObserver接口。
private NERtcPacketObserver mPacketObserver =  new NERtcPacketObserver() {
    //发送音频包回调
    @Override
    public boolean onSendAudioPacket(NERtcPacket packet) {
        if (packet == null) {
            return false;
        }

        ByteBuffer data = packet.getData();
        int size = packet.getSize();
        byte[] txAudioPktBuffer = new byte[size];
        data.get(txAudioPktBuffer, 0, size);

        try {
            // AES-GCM加密会生成认证标签，需要预留空间
            int outputSize = audioPktEncoder.getOutputSize(size);
            byte[] output = new byte[outputSize];
            int encryptedLength = audioPktEncoder.doFinal(txAudioPktBuffer, 0, size, output, 0);
            data.rewind();
            data.put(output, 0, encryptedLength);
            packet.setData(data);
            packet.setSize(encryptedLength);
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (ShortBufferException e) {
            e.printStackTrace();
        }
        return true;
    }

    @Override
    //发送视频包回调
    public boolean onSendVideoPacket(NERtcPacket packet) {
        if (packet == null) {
            return false;
        }

        ByteBuffer data = packet.getData();
        int size = packet.getSize();
        byte[] txVideoPktBuffer = new byte[size];
        data.get(txVideoPktBuffer, 0, size);

        try {
            // AES-GCM加密会生成认证标签，需要预留空间
            int outputSize = videoPktEncoder.getOutputSize(size);
            byte[] output = new byte[outputSize];
            int encryptedLength = videoPktEncoder.doFinal(txVideoPktBuffer, 0, size, output, 0);
            data.rewind();
            data.put(output, 0, encryptedLength);
            packet.setData(data);
            packet.setSize(encryptedLength);
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (ShortBufferException e) {
            e.printStackTrace();
        }
        return true;
    }

    @Override
    //接收音频包回调
    public boolean onReceiveAudioPacket(NERtcPacket packet) {
        if (packet == null) {
            return false;
        }

        ByteBuffer data = packet.getData();
        int size = packet.getSize();
        byte[] rxAudioPktBuffer = new byte[size];
        data.get(rxAudioPktBuffer, 0, size);
        try {
            // AES-GCM解密需要处理认证标签
            int outputSize = audioPktDecoder.getOutputSize(size);
            byte[] output = new byte[outputSize];
            int decryptedLength = audioPktDecoder.doFinal(rxAudioPktBuffer, 0, size, output, 0);
            data.rewind();
            data.put(output, 0, decryptedLength);
            packet.setData(data);
            packet.setSize(decryptedLength);
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (ShortBufferException e) {
            e.printStackTrace();
        }
        return true;
    }

    @Override
    //接收视频包回调
    public boolean onReceiveVideoPacket(NERtcPacket packet) {
        if (packet == null) {
            return false;
        }

        ByteBuffer data = packet.getData();
        int size = packet.getSize();
        byte[] rxVideoPktBuffer = new byte[size];
        data.get(rxVideoPktBuffer, 0, size);
        try {
            // AES-GCM解密需要处理认证标签
            int outputSize = videoPktDecoder.getOutputSize(size);
            byte[] output = new byte[outputSize];
            int decryptedLength = videoPktDecoder.doFinal(rxVideoPktBuffer, 0, size, output, 0);
            data.rewind();
            data.put(output, 0, decryptedLength);
            packet.setData(data);
            packet.setSize(decryptedLength);
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (ShortBufferException e) {
            e.printStackTrace();
        }
        return true;
    }
});
//step4:enable Encryption, before joinChannel
NERtcEncryptionConfig encryptionConfig = new NERtcEncryptionConfig(NERtcEncryptionConfig.EncryptionMode.EncryptionModeCustom, null, mPacketObserver);
int ret = NERtcEx.getInstance().enableEncryption(true, encryptionConfig));


//step5：加入rtc房间，开始音视频业务。
int ret = NERtcEx.getInstance().joinChannel(String token, String channelName, long uid);

//step6: disable (default option), before joinChannel
NERtcEncryptionConfig encryptionConfig = new NERtcEncryptionConfig(NERtcEncryptionConfig.EncryptionMode.EncryptionModeCustom, null, null);
int ret = NERtcEx.getInstance().enableEncryption(false, encryptionConfig));
```
