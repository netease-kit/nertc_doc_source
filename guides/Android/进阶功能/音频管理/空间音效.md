空间音效也称 3D 音效，是通过在音频信号中添加空间信息，使得听众可以感受到声音来自于特定的位置和空间环境。它可以增强音频的真实感和沉浸感，让听众感受到更加真实的声音效果。

## 功能介绍
NERTC SDK 从 V5.4.0 开始支持空间音效。

空间音效可以将实时语音渲染成具有空间方位的效果。同时，空间音效具有房间混响，距离衰减和范围语音等属性，综合使用相关属性可以提升空间音效的真实感和沉浸感。

例如，在游戏中模拟真实世界的空间音效，玩家可以感知说话者的 3D 空间方位。同时，空间音效可以根据双方距离的远近实现语音音量的衰减，使近处的声音更响亮，远处的声音更低。这样可以让玩家更清晰地感受到游戏中的环境和位置信息，增强游戏的沉浸感和真实感。此外，空间音效还可以应用于虚拟现实和增强现实等领域，让用户更真实地感受虚拟环境中的声音效果。

## 功能原理

空间音效涉及到音频源和接收者两个对象。在RTC场景下，开启空间音效时，发送端会在语音中包含自身的坐标信息，远端接收该音频信息时，会将其作为音频源。接收者会基于自身坐标、接收到的音频及其位置，将音频渲染到特定方位，然后进行播放。

空间音效利用头部相关转换函数（HRTF）和声波空间卷积模仿自然声波的传播，使其仿佛来自三维空间中的一个点。空间音效通过方向、距离和环境三个关键因素实现空间感的形成。

空间音效的距离衰减和语音范围如下图所示。

![空间音效.png](https://yx-web-nosdn.netease.im/common/fa10e1464dd9edd71c872f8f86485954/空间音效.png)


## 注意事项

需要用户佩戴**有线耳机**体验空间音效功能，暂不支持蓝牙耳机。

## API 调用时序

```mermaid
sequenceDiagram
    participant 应用层
    participant NERtcSDK
    participant 云信服务器

    Note over 应用层, 云信服务器: 启用并配置空间音效
    rect rgb(191, 223, 255)
    应用层->>NERtcSDK: initSpatializer
    应用层->>NERtcSDK: enableSpatializer
    NERtcSDK -->>应用层: return code
    应用层->>NERtcSDK: setAudioRecvRange
    NERtcSDK-->>应用层: return code
    应用层->>NERtcSDK: setSpatializerRenderMode
    NERtcSDK-->>应用层: return code
    应用层->>NERtcSDK: setAudioProfile
    NERtcSDK-->>应用层: return code
    应用层->>NERtcSDK: setSpatializerRoomProperty 
    应用层->>NERtcSDK: enableSpatializerRoomEffects
    end

    Note over 应用层, 云信服务器: 加入房间
    应用层->>NERtcSDK: joinChannel
    NERtcSDK->>云信服务器: joinChannel
    云信服务器->>NERtcSDK: onJoinChannel
    NERtcSDK->>应用层: onJoinChannel

    Note over 应用层, 云信服务器: 添加或更新位置信息
    rect rgb(191, 223, 255)
    应用层->>NERtcSDK: updateSelfPosition
    NERtcSDK->>云信服务器: Voice data setting & rendering
    end
```

  
## 实现方法

### 1. 启用空间音效

1. 请在**引擎初始化之后（<a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc.html#a2198fb57cd127a8ae136e1f450236e57" target="_blank">`NERtc.init`</a>）**，调用 [`initSpatializer`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#ab0277c0967bed1e1031a3d55603d62c3) 方法初始化空间音效。

2. **加入房间（<a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc.html#a53a91a0990a55753e319f1719761b599" target="_blank">`NERtc.joinChannel`</a>）之前**，调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a759e040aed186b87f2f64dc7ad294bd8" target="_blank">`enableSpatializer`</a> 方法以启用音频空间化, 如果您需要只针对本小队开启 3D 音效, 设置 `applyToTeam ` 为 `true`。

**示例代码**如下：
```
//打开空间音效功能
void Enable3DAudio() {
    NERtcEx.getInstance().initSpatializer();
    NERtcEx.getInstance().enableSpatializer(true, false);

    //audio profile must be stereo,2 channels
    NERtcEx.getInstance().setAudioProfile(NERtcConstants.AudioProfile.MIDDLE_QUALITY_STEREO, NERtcConstants.AudioScenario.MUSIC);
}
```

### 2. 设置距离衰减和语音范围

在加入房间前，调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#ace30c6aedef4078715af558b45a3446b" target="_blank">`setAudioRecvRange`</a> 方法设置空间音效的距离衰减属性和语音范围，该属性可以让声音随着音频源和接收者之间距离的增加逐渐衰减音量。

::: note notice
- 距离衰减属性需要在加入房间之前设置，在通话过程中无法修改该属性，只有退出房间后才可重新设置。
- 空间音效房间内的成员需要**都开启或都关闭**，否则会无法听到对方声音。
:::

**参数描述**如下表所示：

| 参数 | 描述 | 
| ---- | -------------- | 
| audible_distance | 监听器能接收到音频的最大距离，用户的声音在该范围内可被听见。在该范围内，声音将会随距离的增加而衰减，直至超出所设置的范围，则不再有声音。<br> 取值范围：[0,1000] ，默认值为 32。| 
| conversational_distance | 监听器不对音频进行衰减的距离，在该距离范围内，扬声器音频保持其原始音量，超出该范围时，声音将会随距离的增加而衰减。默认值为 1。| 
| roll_off | 距离衰减模式。一共有三种：|\
|| - kNERtcDistanceRolloffLogarithmic（0）：指数衰减。|\
|| - kNERtcDistanceRolloffLinear（1）：线性衰减。|\
|| - kNERtcDistanceRolloffNone（2）：无衰减。|\
|| - kNERtcDistanceRolloffLinearOnly（3）：仅线性衰减, 没有方位效果|


**示例代码**如下：

```
// 设置接收范围和声音衰减模型
void Setup3DAudioRecvRange() {
    //需要在`EnableSpatializer`执行成功之后调用。
    NERtcEx.getInstance().setAudioRecvRange(50, 1, NERtcDistanceRolloffModel.kNERtcDistanceRolloffLinear); 
    // ...
}
```

### 3. 设置渲染模式

在加入房间前，调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a84b7e8fcefb7d1de913d59fdc2c689e8" target="_blank">`setSpatializerRenderMode`</a> 方法设置渲染模式，通过设置 `mode` 参数选择不同复杂程度的算法以实现不同的听觉效果。

其中 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/enumcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1audio_1_1_n_e_rtc_spatializer_render_mode.html" target="_blank">`NERtcSpatializerRenderMode`</a> 类型的各字段说明如下表所示。

| 字段| 描述 | 
| ---- | ---- |
| kNERtcSpatializerRenderStereoPanning | 立体声 PANNing 方法 | 
| kNERtcSpatializerRenderBinauralLowQuality | 低复杂度双耳渲染方法 | 
| kNERtcSpatializerRenderBinauralMediumQuality | 中复杂度双耳渲染方法 | 
| kNERtcSpatializerRenderBinauralHighQuality | 高复杂度双耳渲染方法(推荐) | 
| kNERtcSpatializerRenderRoomEffectsOnly | 仅房间混响 |

**示例代码**如下：

```
// 设置空间语音渲染模式
void Setup3DAudioRenderMode() {
    //需要在`EnableSpatializer`执行成功之后调用。

    NERtcEx.getInstance().setSpatializerRenderMode(RtcSpatializerRenderMode.kNERtcSpatializerRenderBinauralHighQuality); 
    // ...
}
```

### 4. 设置音频属性

在加入房间前，调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc.html#a577e39135f6388f4d02e4cb72f97a9f3" target="_blank">`setAudioProfile`</a> 方法将音频类型（`profile`）设置为 `MIDDLE_QUALITY_STEREO` 或者 `HIGH_QUALITY_STEREO`，并将音频场景（`scenario`）设置为 `MUSIC`。

```
// 设置音频属性
void Setup3DAudioProfile() {
    //需要在`Initialize`执行成功之后,`JoinChannel`之前调用
    NERtcEx.getInstance().setAudioProfile(NERtcConstants.AudioProfile.MIDDLE_QUALITY_STEREO, NERtcConstants.AudioScenario.MUSIC); 
    // ...
}
```

### 5. 设置房间混响属性（可选）

1. 调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#aa2f6bd290b8e18adbc048b6819cd192b" target="_blank">`setSpatializerRoomProperty`</a> 方法设置 `roomProperty` 参数预设的房间大小，混响时长，混响增益，音色亮度等参数，以调整房间混响效果。

其中 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1audio_1_1_n_e_rtc_spatializer_room_property.html" target="_blank">`NERtcSpatializerRoomProperty`</a> 类型的各字段说明如下表所示。

| 参数 | 类型 | 描述 |
| ---- | ---- |---- |
| NERtcSpatializerRoomCapacity | NERtcSpatializerRoomCapacity | 房间大小，默认值为 `kNERtcSpatializerRoomCapacitySmall`。<br> 房间大小的枚举值请参见[`NERtcSpatializerRoomCapacity`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/enumcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1audio_1_1_n_e_rtc_spatializer_room_capacity.html)|
|NERtcSpatializerMaterialName  |NERtcSpatializerMaterialName | 房间材质，默认值为 `kNERtcSpatializerMaterialTransparent`。<br>更多的房间材质请参见[`NERtcSpatializerMaterialName`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/enumcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1audio_1_1_n_e_rtc_spatializer_material_name.html) |
| reflectionScalar | float | 混响反射比例因子，默认值为 1.0 |
| reverbGain |float| 混响增益比例因子，默认值为 1.0 |
| reverbTime |float| 混响时间比例因子，默认值为 1.0 |
| reverbBrightness |float| 混响音色亮度 |

2. 调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a757a10b76e43bd46345168b1066c36ba" target="_blank">`enableSpatializerRoomEffects`</a> 方法，设置 `enable` 参数为 `true` 或 `false` 以开启或关闭空间音效的房间混响效果。
3. 调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a759e040aed186b87f2f64dc7ad294bd8" target="_blank">`enableSpatializer`</a> 方法，设置 `enable` 参数为 `true` 或 `false` 以开启或关闭 3D 音效。

    3D 音效可以让声音有 3D 空间感且按距离衰减。

### 6. 添加或更新位置信息

在加入房间后，调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1_n_e_rtc_ex.html#a7b8caec0727c1baef411459bb6a4c89f" target="_blank">`updateSelfPosition`</a> 方法并设置 `info` 参数，以更新音频源或接收者的空间位置信息 <a href="https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/Latest/zh/html/classcom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1audio_1_1_n_e_rtc_position_info.html" target="_blank">`NERtcPositionInfo`</a>，从而实现空间音频定位特效。
::: note note
- 通常在 3D 网络游戏开始后，都能获取地图上角色 `GameObject` 相互的坐标，此坐标即调用 `updateSelfPosition` 方法时需要更新的角色坐标。
- 建议在一定间隔内更新角色位置信息，以保证画面和音频位置同步，推荐更新频率为 10 ~ 25次/秒。
:::

| 参数 | 描述 | 
| ---- | -------------- | 
| mSpeakerPosition | 说话者的位置信息，三个值依次表示X、Y、Z的坐标值。默认值{0,0,0}| 
| mSpeakerQuaternion | 说话者的旋转信息，通过四元组来表示，数据格式为{w, x, y, z}。默认值{0,0,0,0}<note type="note">该参数设置的值暂时不起作用，保持默认值即可。</note>| 
| mHeadPosition | 接收者的位置信息，三个值依次表示X、Y、Z的坐标值。默认值{0,0,0}|
| mHeadQuaternion| 接收者的旋转信息，通过四元组来表示，数据格式为{w, x, y, z}。默认值{0,0,0,0}|


![3D坐标.png](https://yx-web-nosdn.netease.im/common/634f363e80d3b44a9507b6196ee0541c/3D坐标.png)


**示例代码**如下：
//step1:打开空间音效
NERtcEx.getInstance().initSpatializer();
NERtcEx.getInstance().enableSpatializer(true, false);

//step2:设置空间音效的相关属性
//step2.1:设置音频接收范围
NERtcEx.getInstance().setAudioRecvRange(mAudibleDistance, mConverDistance,
    NERtcDistanceRolloffModel.values()[DistanceRollOff]);
//step2.2:设置空间音效渲染模式
ret = NERtcEx.getInstance().setSpatializerRenderMode(NERtcSpatializerRenderMode.values()[mRoomRenderMode]);
//step2.3:开启空间音效房间混响效果
NERtcEx.getInstance().enableSpatializerRoomEffects(mRoomSpatializerEffect);
//step2.4:设置空间音效房间属性
// 创建房间属性对象
NERtcSpatializerRoomProperty roomProperty = new NERtcSpatializerRoomProperty();
// 设置房间大小
roomProperty.roomCapacity = NERtcSpatializerRoomCapacity.values()[mRoomSize];
// 设置房间材质
roomProperty.material = NERtcSpatializerMaterialName.values()[mRoomMaterial];
// 设置反射比例
roomProperty.reflectionScalar = mReflectionScalar;
// 设置混响增益
roomProperty.reverbGain = mReverbGain;
// 设置混响时间
roomProperty.reverbTime = mReverbTime;
// 设置混响亮度
roomProperty.reverbBrightness = mReverbBrightness;
ret = NERtcEx.getInstance().setSpatializerRoomProperty(roomProperty);

//step3:添加或更新位置信息
float[] mouseCoord = new float[]{Float.parseFloat(mouseCoor[0]), Float.parseFloat(mouseCoor[1]), Float.parseFloat(mouseCoor[2])};
float[] earCoord = new float[]{Float.parseFloat(earCoor[0]), Float.parseFloat(earCoor[1]), Float.parseFloat(earCoor[2])};
float[] mouseCoordFourth = new float[]{Float.parseFloat(mouseCoorFourth[0]), Float.parseFloat(mouseCoorFourth[1]), Float.parseFloat(mouseCoorFourth[2]), Float.parseFloat(mouseCoorFourth[3])};
float[] earCoordFourth = new float[]{Float.parseFloat(earCoorFourth[0]), Float.parseFloat(earCoorFourth[1]), Float.parseFloat(earCoorFourth[2]), Float.parseFloat(earCoorFourth[3])};
NERtcPositionInfo info = new NERtcPositionInfo(mouseCoord, mouseCoordFourth, earCoord, earCoordFourth);
ret = NERtcEx.getInstance().updateSelfPosition(info);

```Java#
//打开一个定时器，每200ms调用一次下面的函数，就会有3d音效的效果
private void RotationAStep() {

        float[] position = new float[]{9.0f, 0.0f, 9.0f};
        float[] queternion = new float[]{0.0f, 0.0f, 0.0f, 0.0f};
        if (mRoomSize == 0) {
            position[0] = 1.0f;
            position[2] = 1.0f;
        } else if (mRoomSize == 1) {
            position[0] = 2.0f;
            position[2] = 2.0f;
        } else if (mRoomSize == 2) {
            position[0] = 4.0f;
            position[2] = 4.0f;
        } else if (mRoomSize == 3) {
            position[0] = 9.0f;
            position[2] = 9.0f;
        } else {
            position[0] = 9.0f;
            position[2] = 9.0f;
        }

        rotation_step++;
        if (rotation_step == 180) {
            rotation_step = 0;
        }

        queternion[0] = 0.0f;
        queternion[1] = (float) Math.sin((2.0f * Math.PI * rotation_step) / 180.0f);
        queternion[2] = 0.0f;
        queternion[3] = (float) Math.cos((2.0f * Math.PI * rotation_step) / 180.0f);
        float[] mouseCoord = position;
        float[] earCoord = position;
        float[] mouseCoordForth = queternion;
        float[] earCoordForth = queternion;
        NERtcPositionInfo info = new NERtcPositionInfo(mouseCoord, mouseCoordForth, earCoord, earCoordForth);
        int res = NERtcEx.getInstance().updateSelfPosition(info);
        Log.i(TAG, "updateSelfPosition:" + res);
    }
```


