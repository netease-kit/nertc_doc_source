在金融行业等对用户隐私数据要求较高的行业场景中，往往需要额外采用媒体流加密方式保障用户数据在网络传输过程中的安全性、保障用户的信息安全和数据安全。网易云信在默认加密算法的基础上，提供了内置国密加密和自定义加密方案，进一步保障数据安全。

## 功能介绍

媒体流加密指在音视频流传输过程中对音视频数据进行加密，网易云信提供以下两种加密方式。

- 内置国密加密：使用 NERTC SDK 预置的国密加密模式给媒体流加密。
- 自定义加密：通过 NERTC SDK 提供的数据包观测器来自定义媒体流的加密模式。网易云信服务器可以对自定义加密后的媒体流进行传输，加解密均在客户端完成。

## 注意事项
- 您只可选择 SDK 内置的国密加密算法或自定义加密算法，两种加密算法不可同时使用，否则会报错 `ENGINE_ERROR_INVALID_STATE（30005）`。
- 同一房间内，所有调用 `enableEncrytion` 方法开启媒体流加密的用户必须使用相同的加密模式、密钥等，否则加入房间时会报错 `kNERtcErrEncryptNotSuitable（30113）`。

**内置加密的注意事项：**

- 安全起见，若您选择 SDK 内置加密算法，建议每次启用媒体流加密时都更换新的密钥。


**自定义加密的注意事项：**

- 密钥等参数均由您自己的服务器进行分发。

- 若您选择自定义加密，请在创建房间前注册自定义加密对象，该房间的属性为“自定义加密房间”。后续用户必须也启用自定义加密才可成功加入，否则加入房间时会报错  `kNERtcErrEncryptNotSuitable（30113）`。

- 加入“自定义加密房间”的双方若使用了不同的自定义加密算法，会强行进行加解密，会导致视频画面绿屏，音频机械音。

- 若要在某个 RTC 音视频通话房间中启用自定义加密，则必须保证加入房间的用户，使用 v4.6.53 及以上版本的 SDK（V5.3 版本不支持），且仅限 iOS、Android、linux、macOS 和 Web 五个端，不支持小程序、Sip、Linux等其他平台客户端加入“自定义加密房间”。
- 使用了自定义加密的 RTC 音视频通话房间，不支持使用云端录制、云端播放、旁路推流等媒体服务，不支持安全通服务，不支持服务端本地录制服务。

## 开通媒体流加密

1. 登录<a href="https://app.yunxin.163.com/index#/" target="_blank">网易云信控制台</a>。

2. 在首页单击指定应用名称。
3. 在**产品总览**区域，单击**音视频通话 2.0** 产品选项卡中的**功能配置**。


    ![功能配置.png](https://yx-web-nosdn.netease.im/common/50fdee5139f9e30204445b9386f205cd/功能配置.png)



4. 单击**高级功能**页签，单击 **音视频媒体流加密** 的开关按钮，开启媒体流加密。


    ![开通媒体流加密.png](https://yx-web-nosdn.netease.im/common/fae25d4ed33e0eeb7777f09d1fed3a51/开通媒体流加密.png)


5. 单击**确定**。

## 内置加密

### 功能原理

![内置加密.png](https://yx-web-nosdn.netease.im/common/78718e990a3fdeb0ec80504a4ebfcac5/内置加密.png)
<br>**启用内置国密加密的实现步骤**：
1. 您的服务端生成密钥和盐并加密传输给客户端。
2. 用户 A 采集音视频流之后，通过 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/linux/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a4192d089c314b9090fc0d868ca3d2bf4) 启用加密并传入加密模式、密钥和盐，SDK 会用您选择的加密算法对音视频流进行加密，并将加密后的音视频流传输到网易云信音视频服务。
3. 网易云信音视频服务中转加密的音视频流。
4. 用户 B 收到音视频流之后，通过 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/linux/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a4192d089c314b9090fc0d868ca3d2bf4) 传入相同的加密模式、密钥和盐，SDK 会使用同样的加密算法和密钥对媒体流解密，并解码与渲染。



### 配置步骤

1. 在您的服务端生成密钥。参考以下命令通过 OpenSSL 随机生成 String 型、16 字节的密钥。

```
// 随机生成一个 string 型、16 字节的密钥，并将该密钥传入 enableEncryption 的 config 参数。
openssl rand -hex 16
dba643c8ba6b6dc738df43d9fd624293b4b12d87a60f518253bd10ba98c48453
```

2. 客户端从服务端获取 String 型密钥，并在加入房间前调用 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/linux/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a4192d089c314b9090fc0d868ca3d2bf4) 方法开启媒体流加密功能，设置媒体加密模式为 `kNERtcGMCryptoSM4ECB` ，并在 `config` 的 `key` 参数中传入密钥。

::: note note
- 加密模式目前仅支持国密 SM4 对称加密算法。
- 密钥由服务端生成，格式为 String 类型的字符串。
:::

### 示例代码

```
bool encryptEnabled = true;
nertc::NERtcEncryptionConfig config;
config.mode = nertc::kNERtcGMCryptoSM4ECB;
std::string key_sub = "Your encrypt key";
int len = key_sub.length();
if (kNERtcEncryptByteLength < len) {
    key_sub = key.substr(0, kNERtcEncryptByteLength);
}
memset(config.key, 0, kNERtcEncryptByteLength * sizeof(char));
memcpy(config.key, key_sub.c_str(), key_sub.size() * sizeof(char));
nrtc_engine_.rtc_engine_->enableEncryption(encryptEnabled, config);
```



## 自定义加密

### 功能原理

![自定义加密.png](https://yx-web-nosdn.netease.im/common/b3d3177c29f1d8d571ff42e10c648fdf/自定义加密.png)
<br>**启用自定义加密的实现步骤**：
1. 您的服务端生成密钥并加密传输给客户端。
2. 用户 A 采集音视频流之后，借助返回的音视频数据的缓存地址等信息启用自定义加密，SDK 会将加密后的音视频流传输到网易云信音视频服务。
3. 网易云信音视频服务中转加密的音视频流。
4. 用户 B 收到音视频流之后，借助返回的音视频数据的缓存地址等信息启用自定义解密，选择和用户 A 相同的加密算法对媒体流解密，SDK 会将解密后的媒体流进行解码与渲染。

### 配置步骤

用户 A 采集音视频流之后，通过 `enableEncryption` 方法的  [`INERtcPacketObserver`](https://doc.yunxin.163.com/nertc/api-refer/linux/doxygen/Latest/zh/html/classnertc_1_1_i_n_e_rtc_packet_observer.html) 类，进行监听自定义加密回调，实现自定义加密功能。参考步骤如下：

1. 在初始化后加入房间前，调用 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/linux/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a4192d089c314b9090fc0d868ca3d2bf4) 方法开启媒体流加密功能，设置媒体加密模式为 `NERtcEncryptionModeCustom` ， 在 `observer` 参数中注册数据包观测器，监听数据包采集回调。
2. 遵循 `NERtcEnginePacketObserver` 协议实现 [`INERtcPacketObserver`](https://doc.yunxin.163.com/nertc/api-refer/linux/doxygen/Latest/zh/html/classnertc_1_1_i_n_e_rtc_packet_observer.html) 自定义加密观察对象类，帮助您通过回调的音视频包相关参数进行自定义加密处理。
3. 加入房间后通过 `onSendAudioPacket` 和 `onSendVideoPacket` 回调的 `packet` 参数进行自定义加密，或通过 `onReceiveAudioPacket` 和 `onReceiveVideoPacket` 回调的 `packet` 参数进行自定义解密。
4. 若您想取消自定义加密，请在离开房间后调用 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/linux/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a4192d089c314b9090fc0d868ca3d2bf4) 方法，并将 `enable`参数设置为 `false`。

### 示例代码

```
//step1:添加依赖
#include <openssl/aes.h>
#include <openssl/evp.h>
//step2:准备如下自定义加解密类，需要遵循NERtcEnginePacketObserver协议。
class NRTCEngine : public nertc::INERtcPacketObserver{
    virtual bool onSendAudioPacket(nertc::NERtcMediaPacket &packet) override;
    virtual bool onSendVideoPacket(nertc::NERtcMediaPacket &packet) override;
    virtual bool onReceiveAudioPacket(nertc::NERtcMediaPacket &packet) override;
    virtual bool onReceiveVideoPacket(nertc::NERtcMediaPacket &packet) override;

public:
     nertc::IRtcEngineEx *rtc_engine_; //引擎
     nertc::NERtcEngineContext rtc_engine_context_;
}

// AES-256-GCM加密/解密函数
void AES_GCM_Process(const std::string& key, unsigned char *data, int length, bool encrypt) {
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    unsigned char iv[12] = {0}; // 初始化向量，实际使用时应为随机值

    if (encrypt) {
        EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, (const unsigned char*)key.c_str(), iv);

        int len, ciphertext_len;
        EVP_EncryptUpdate(ctx, data, &len, data, length);
        ciphertext_len = len;

        EVP_EncryptFinal_ex(ctx, data + len, &len);
        ciphertext_len += len;

        // 获取认证标签
        unsigned char tag[16];
        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, tag);
        // 在实际应用中，需要将tag附加到密文后发送
    } else {
        EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, (const unsigned char*)key.c_str(), iv);

        int len, plaintext_len;
        EVP_DecryptUpdate(ctx, data, &len, data, length);
        plaintext_len = len;

        // 设置认证标签（实际应从密文中提取）
        unsigned char tag[16] = {0};
        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, tag);

        EVP_DecryptFinal_ex(ctx, data + len, &len);
        plaintext_len += len;
    }

    EVP_CIPHER_CTX_free(ctx);
}

//发送视频包回调
bool NRTCEngine::onSendVideoPacket(nertc::NERtcMediaPacket &packet) {
    std::string key = kCustomEncryptKey;
    AES_GCM_Process(key, (unsigned char *)packet.buffer, packet.size, true);
    return true; //是否保留该包，YES为保留，NO为丢弃
}
//接收音频包回调
bool NRTCEngine::onReceiveAudioPacket(nertc::NERtcMediaPacket &packet) {
    std::string key = kCustomEncryptKey;
    AES_GCM_Process(key, (unsigned char *)packet.buffer, packet.size, false);
    return true; //是否保留该包，YES为保留，NO为丢弃
}
//接收视频包回调
bool NRTCEngine::onReceiveVideoPacket(nertc::NERtcMediaPacket &packet) {
    std::string key = kCustomEncryptKey;
    AES_GCM_Process(key, (unsigned char *)packet.buffer, packet.size, false);
    return true; //是否保留该包，YES为保留，NO为丢弃
}
//发送音频包回调
bool NRTCEngine::onSendAudioPacket(nertc::NERtcMediaPacket &packet) {
    std::string key = kCustomEncryptKey;
    AES_GCM_Process(key, (unsigned char *)packet.buffer, packet.size, true);
    return true; //是否保留该包，YES为保留，NO为丢弃
}

//step3：初始化引擎。
NRTCEngine nrtc_engine_;
nrtc_engine_.rtc_engine_ = (IRtcEngineEx *)createNERtcEngine();
memset(&nrtc_engine_.rtc_engine_context_, 0, sizeof(nertc::NERtcEngineContext));
nrtc_engine_.rtc_engine_context_.app_key = app_key_.c_str();
nrtc_engine_.rtc_engine_context_.log_dir_path = log_dir_path_.c_str();
nrtc_engine_.rtc_engine_context_.log_level = rtc_parameter_.log_level;
nrtc_engine_.rtc_engine_context_.log_file_max_size_KBytes = log_file_max_size_KBytes;
nrtc_engine_.rtc_engine_context_.event_handler = this;
nrtc_engine_.rtc_engine_context_.server_config = serverAddress;
nrtc_engine_.rtc_engine_->initialize(nrtc_engine_.rtc_engine_context_);

//step4：注册数据包观测器。
bool encryptEnabled = true;
nertc::NERtcEncryptionConfig config;
config.mode = nertc::NERtcEncryptionModeCustom;
config.observer = nrtc_engine_;
nrtc_engine_.rtc_engine_->enableEncryption(encryptEnabled, config);

//step5：入会
nrtc_engine_.rtc_engine_->joinChannel(token, room_name, cur_my_uid_);
```

