在金融行业等对用户隐私数据要求较高的行业场景中，往往需要额外采用媒体流加密方式保障用户数据在网络传输过程中的安全性、保障用户的信息安全和数据安全。网易云信在默认加密算法的基础上，提供了内置国密加密和自定义加密方案，进一步保障数据安全。

## 功能介绍

媒体流加密指在音视频流传输过程中对音视频数据进行加密，网易云信提供以下两种加密方式。

- 内置国密加密：使用 NERTC SDK 预置的国密加密模式给媒体流加密。
- 自定义加密：通过 NERTC SDK 提供的数据包观测器来自定义媒体流的加密模式。网易云信服务器可以对自定义加密后的媒体流进行传输，加解密均在客户端完成。

## 注意事项
- 您只可选择 SDK 内置的国密加密算法或自定义加密算法，两种加密算法不可同时使用，否则会报错 `ENGINE_ERROR_INVALID_STATE（30005）`。
- 同一房间内，所有调用 `enableEncrytion` 方法开启媒体流加密的用户必须使用相同的加密模式、密钥等，否则加入房间时会报错 `kNERtcErrEncryptNotSuitable（30113）`。

**内置加密的注意事项：**

- 安全起见，若您选择 SDK 内置加密算法，建议每次启用媒体流加密时都更换新的密钥。


**自定义加密的注意事项：**

- 由于自定义媒体流加密对设备性能要求较高，建议您准备好以下开发环境：
    - 可支持的 iOS 设备必须配有 A9 及以上的芯片。
    - 苹果系统版本要求 iOS 9.0 及以上。
- 密钥等参数均由您自己的服务器进行分发。

- 若您选择自定义加密，请在创建房间前注册自定义加密对象，该房间的属性为“自定义加密房间”。后续用户必须也启用自定义加密才可成功加入，否则加入房间时会报错  `kNERtcErrEncryptNotSuitable（30113）`。

- 加入“自定义加密房间”的双方若使用了不同的自定义加密算法，会强行进行加解密，会导致视频画面绿屏，音频机械音。

- 若要在某个 RTC 音视频通话房间中启用自定义加密，则必须保证加入房间的用户，使用 v4.6.53 及以上版本的 SDK（V5.3 版本不支持），且仅限 iOS、Android、Windows、macOS 和 Web 五个端，不支持小程序、Sip、Linux等其他平台客户端加入“自定义加密房间”。
- 使用了自定义加密的 RTC 音视频通话房间，不支持使用云端录制、云端播放、旁路推流等媒体服务，不支持安全通服务，不支持服务端本地录制服务。

## 开通媒体流加密

1. 登录<a href="https://app.yunxin.163.com/index#/" target="_blank">网易云信控制台</a>。

2. 在首页单击指定应用名称。
3. 在**产品总览**区域，单击**音视频通话 2.0** 产品选项卡中的**功能配置**。


    ![功能配置.png](https://yx-web-nosdn.netease.im/common/50fdee5139f9e30204445b9386f205cd/功能配置.png)



4. 单击**高级功能**页签，单击 **音视频媒体流加密** 的开关按钮，开启媒体流加密。

    ![开通媒体流加密.png](https://yx-web-nosdn.netease.im/common/fae25d4ed33e0eeb7777f09d1fed3a51/开通媒体流加密.png)


5. 单击**确定**。

## 内置加密

### 功能原理

![内置加密.png](https://yx-web-nosdn.netease.im/common/78718e990a3fdeb0ec80504a4ebfcac5/内置加密.png)
<br>**启用内置国密加密的实现步骤**：
1. 您的服务端生成密钥和盐并加密传输给客户端。
2. 用户 A 采集音视频流之后，通过 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine_ex-p.html#a5fec9e25c3476b74e05f713380c27dd1) 启用加密并传入加密模式和密钥，SDK 会用您选择的加密算法对音视频流进行加密，并将加密后的音视频流传输到网易云信音视频服务。
3. 网易云信音视频服务中转加密的音视频流。
4. 用户 B 收到音视频流之后，通过 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine_ex-p.html#a5fec9e25c3476b74e05f713380c27dd1) 传入相同的加密模式和密钥，SDK 会使用同样的加密算法和密钥对媒体流解密，并解码与渲染。

### 配置步骤

1. 在您的服务端生成密钥。参考以下命令通过 OpenSSL 随机生成 String 型、16 字节的密钥。

```
// 随机生成一个 string 型、16 字节的密钥，并将该密钥传入 enableEncryption 的 config 参数。
openssl rand -hex 16
dba643c8ba6b6dc738df43d9fd624293b4b12d87a60f518253bd10ba98c48453
```

2. 客户端从服务端获取 String 型密钥，并在加入房间前调用 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine_ex-p.html#a5fec9e25c3476b74e05f713380c27dd1) 方法开启媒体流加密功能，设置媒体加密模式为 `NERtcEncryptionModeGMCryptoSM4ECB`，并在 `config` 的 `key` 参数中传入密钥。

::: note note
- 加密模式目前仅支持国密 SM4 对称加密算法。
- 密钥由服务端生成，格式为 String 类型的字符串。
:::

### 示例代码

```
  NSString *encryptKey = @"Your encrypt key";
  NERtcEncryptionConfig *config = [[NERtcEncryptionConfig alloc]init];
  config.mode = NERtcEncryptionModeGMCryptoSM4ECB;
  config.key = encryptKey;
   
  [[NERtcEngine sharedEngine] enableEncryption:encryptEnabled config:config];
```



## 自定义加密

### 功能原理

![自定义加密.png](https://yx-web-nosdn.netease.im/common/b3d3177c29f1d8d571ff42e10c648fdf/自定义加密.png)
<br>**启用自定义加密的实现步骤**：
1. 您的服务端生成密钥并加密传输给客户端。
2. 用户 A 采集音视频流之后，借助返回的音视频数据的缓存地址等信息启用自定义加密，SDK 会将加密后的音视频流传输到网易云信音视频服务。
3. 网易云信音视频服务中转加密的音视频流。
4. 用户 B 收到音视频流之后，借助返回的音视频数据的缓存地址等信息启用自定义解密，选择和用户 A 相同的加密算法对媒体流解密，SDK 会将解密后的媒体流进行解码与渲染。

### 配置步骤

用户 A 采集音视频流之后，通过 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine_ex-p.html#a5fec9e25c3476b74e05f713380c27dd1) 方法，并注册 [`NERtcPacketObserver`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/V4.6.53/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1encryption_1_1_n_e_rtc_packet_observer.html)  监听自定义加密回调，实现自定义加密功能。参考步骤如下：

1. 遵循 NERtcEnginePacketObserver 协议实现  [`NERtcPacketObserver`](https://doc.yunxin.163.com/nertc/api-refer/android/doxygen/V4.6.53/zh/html/interfacecom_1_1netease_1_1lava_1_1nertc_1_1sdk_1_1encryption_1_1_n_e_rtc_packet_observer.html) 自定义加密观察对象类，帮助您通过回调的音视频包相关参数进行自定义加密处理。
2. 在初始化后加入房间前，调用 [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine_ex-p.html#a5fec9e25c3476b74e05f713380c27dd1) 开启媒体流加密功能，设置媒体加密模式为 `NERtcEncryptionModeCustom` ， 在 `observer` 参数中传入第一步中实现的观察对象，注册数据包观测器，监听数据包采集回调。
3. 加入房间后通过 `onSendAudioPacket` 和 `onSendVideoPacket` 回调的 `packet` 参数进行自定义加密，或通过 `onReceiveAudioPacket`和`onReceiveVideoPacket`回调的 `packet` 参数进行自定义解密。
4. 若您想取消自定义加密，请在离开房间后调用  [`enableEncryption`](https://doc.yunxin.163.com/nertc/api-refer/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine_ex-p.html#a5fec9e25c3476b74e05f713380c27dd1) 方法，指定`config`中 `mode`为`NERtcEncryptionModeCustom`， 并将 `enable`参数设置为 `false`。。


### 示例代码

```
//step1：添加依赖。
#import <CommonCrypto/CommonCrypto.h>

//step2：初始化引擎。
[[NERtcEngine sharedEngine] setupEngineWithContext:context];

//step3:准备如下自定义加解密类，需要遵循NERtcEnginePacketObserver协议。
@interface NTESDemoCustomEncryptObserver : NSObject<NERtcEnginePacketObserver>
@property (nonatomic, strong) NSData *aesKey;
@property (nonatomic, strong) NSData *aesIv;
@end
@implementation NTESDemoCustomEncryptObserver

- (instancetype)init {
    self = [super init];
    if (self) {
        // 初始化密钥和IV，实际使用时应从服务端获取
        NSString *keyString = @"I_AM_A_KEY_32BYTES_LONG_KEY_FOR_AES";
        self.aesKey = [keyString dataUsingEncoding:NSUTF8StringEncoding];
        // AES-GCM推荐使用12字节的IV
        uint8_t ivBytes[12] = {0};
        self.aesIv = [NSData dataWithBytes:ivBytes length:12];
    }
    return self;
}

// AES-256-GCM加密
- (NSData *)AES256GCMEncrypt:(NSData *)data {
    CCCryptorStatus status;
    CCCryptorRef cryptor;

    // 初始化加密器
    status = CCCryptorCreate(kCCEncrypt,
                          kCCAlgorithmAES,
                          kCCOptionPKCS7Padding | kCCModeGCM,
                          [self.aesKey bytes],
                          kCCKeySizeAES256,
                          [self.aesIv bytes],
                          &cryptor);

    if (status != kCCSuccess) {
        return nil;
    }

    // 创建输出缓冲区（预留空间用于认证标签）
    size_t dataOutAvailable = [data length] + kCCBlockSizeAES128;
    NSMutableData *encryptedData = [NSMutableData dataWithLength:dataOutAvailable];
    size_t dataOutMoved = 0;

    status = CCCryptorUpdate(cryptor,
                            [data bytes],
                            [data length],
                            [encryptedData mutableBytes],
                            dataOutAvailable,
                            &dataOutMoved);

    if (status != kCCSuccess) {
        CCCryptorRelease(cryptor);
        return nil;
    }

    size_t finalOutAvailable = dataOutAvailable - dataOutMoved;
    size_t finalOutMoved = 0;
    status = CCCryptorFinal(cryptor,
                           [encryptedData mutableBytes] + dataOutMoved,
                           finalOutAvailable,
                           &finalOutMoved);

    if (status != kCCSuccess) {
        CCCryptorRelease(cryptor);
        return nil;
    }

    [encryptedData setLength:dataOutMoved + finalOutMoved];
    CCCryptorRelease(cryptor);

    return encryptedData;
}

// AES-256-GCM解密
- (NSData *)AES256GCMDecrypt:(NSData *)data {
    CCCryptorStatus status;
    CCCryptorRef cryptor;

    // 初始化解密器
    status = CCCryptorCreate(kCCDecrypt,
                          kCCAlgorithmAES,
                          kCCOptionPKCS7Padding | kCCModeGCM,
                          [self.aesKey bytes],
                          kCCKeySizeAES256,
                          [self.aesIv bytes],
                          &cryptor);

    if (status != kCCSuccess) {
        return nil;
    }

    // 创建输出缓冲区
    size_t dataOutAvailable = [data length];
    NSMutableData *decryptedData = [NSMutableData dataWithLength:dataOutAvailable];
    size_t dataOutMoved = 0;

    status = CCCryptorUpdate(cryptor,
                            [data bytes],
                            [data length],
                            [decryptedData mutableBytes],
                            dataOutAvailable,
                            &dataOutMoved);

    if (status != kCCSuccess) {
        CCCryptorRelease(cryptor);
        return nil;
    }

    size_t finalOutAvailable = dataOutAvailable - dataOutMoved;
    size_t finalOutMoved = 0;
    status = CCCryptorFinal(cryptor,
                           [decryptedData mutableBytes] + dataOutMoved,
                           finalOutAvailable,
                           &finalOutMoved);

    if (status != kCCSuccess) {
        CCCryptorRelease(cryptor);
        return nil;
    }

    [decryptedData setLength:dataOutMoved + finalOutMoved];
    CCCryptorRelease(cryptor);

    return decryptedData;
}

//发送音频包回调
- (BOOL)onSendAudioPacket:(NERtcPacket *)packet {
    if (_isDropSendAudio) {
        return NO;
    }

    NSData *inputData = [NSData dataWithBytes:packet.buffer length:packet.size];
    NSData *encryptedData = [self AES256GCMEncrypt:inputData];

    if (encryptedData) {
        memcpy(packet.buffer, [encryptedData bytes], [encryptedData length]);
        packet.size = [encryptedData length];
    }

    return YES;
}
//发送视频包回调
- (BOOL)onSendVideoPacket:(NERtcPacket *)packet {
    if (_isDropSendVideo) {
        return NO;
    }

    NSData *inputData = [NSData dataWithBytes:packet.buffer length:packet.size];
    NSData *encryptedData = [self AES256GCMEncrypt:inputData];

    if (encryptedData) {
        memcpy(packet.buffer, [encryptedData bytes], [encryptedData length]);
        packet.size = [encryptedData length];
    }

    return YES;
}
//接收音频包回调
- (BOOL)onReceiveAudioPacket:(NERtcPacket *)packet {
  if (_isDropRecvAudio) {
        return NO;
    }

    NSData *inputData = [NSData dataWithBytes:packet.buffer length:packet.size];
    NSData *decryptedData = [self AES256GCMDecrypt:inputData];

    if (decryptedData) {
        memcpy(packet.buffer, [decryptedData bytes], [decryptedData length]);
        packet.size = [decryptedData length];
    }

    return YES;
}
//接收视频包回调
- (BOOL)onReceiveVideoPacket:(NERtcPacket *)packet {
  if (_isDropRecvVideo) {
        return NO;
    }

    NSData *inputData = [NSData dataWithBytes:packet.buffer length:packet.size];
    NSData *decryptedData = [self AES256GCMDecrypt:inputData];

    if (decryptedData) {
        memcpy(packet.buffer, [decryptedData bytes], [decryptedData length]);
        packet.size = [decryptedData length];
    }

    return YES;
}
@end

//step4：打开自定义加密。
self.customEncryptObserver = [[NTESDemoCustomEncryptObserver alloc] init];

NERtcEncryptionConfig *config = [[NERtcEncryptionConfig alloc]init];
config.mode = NERtcEncryptionModeCustom;
config.observer = self.customEncryptObserver;

//打开自定义加密
[[NERtcEngine sharedEngine] enableEncryption:YES config:config];


//step5：加入rtc房间，开始音视频业务。
 [[NERtcEngine sharedEngine] joinChannelWithToken:token channelName:channelName myUid:myUid completion:^(NSError * _Nullable error, uint64_t channelId, uint64_t elapesd, uint64_t uid) {
            
    }];
```

